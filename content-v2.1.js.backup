// Prevent multiple injections
if (typeof window.quickFillFormsV2Instance !== 'undefined') {
    console.log('‚ö†Ô∏è QuickFill instance already exists, skipping initialization');
} else {

// QuickFill Microsoft Forms v2.1 - Enhanced Content Script
console.log('üöÄ QuickFill Microsoft Forms v2.1 loaded');

class QuickFillFormsV2 {
    constructor() {
        this.isRunning = false;
        this.debug = true;
        this.delay = (min, max) => new Promise(resolve => setTimeout(resolve, Math.random() * (max - min) + min));
        this.sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        this.currentFormData = {};
        this.processedQuestions = new Set(); // Track processed questions per page
        this.submitCount = 0; // Counter for submitted forms
        this.sessionStartTime = null; // Will be set when starting
        this.setupMessageListener();
        this.restoreSession(); // Restore session if exists
        this.log('üéØ QuickFill v2.1 initialized');
    }

    log(message, type = 'info') {
        if (!this.debug) return;
        const timestamp = new Date().toLocaleTimeString();
        const prefix = type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : type === 'success' ? '‚úÖ' : 'üîç';
        console.log(`${prefix} [${timestamp}] QuickFill: ${message}`);
    }

    updateSubmitCount(increment = true) {
        if (increment) {
            this.submitCount++;
            this.log(`üìä Form submitted! Total: ${this.submitCount}`, 'success');
        }
        
        // Save updated count to storage
        this.saveSessionToStorage();
        
        // Send update to popup
        this.sendStatusUpdate({
            submitCount: this.submitCount,
            sessionDuration: this.sessionStartTime ? Date.now() - this.sessionStartTime : 0,
            sessionStartTime: this.sessionStartTime,
            isRunning: this.isRunning
        });
    }

    sendStatusUpdate(status) {
        try {
            chrome.runtime.sendMessage({
                action: 'statusUpdate',
                data: status
            }).catch(error => {
                // Popup might be closed, ignore error
                this.log(`Status update failed (popup likely closed): ${error.message}`);
            });
        } catch (error) {
            this.log(`Error sending status update: ${error.message}`);
        }
    }

    async saveSessionToStorage() {
        try {
            const sessionData = {
                sessionStartTime: this.sessionStartTime,
                sessionActive: this.isRunning,
                submitCount: this.submitCount
            };
            
            await chrome.storage.local.set(sessionData);
            console.log(`üíæ Session data saved to storage:`, sessionData);
            console.log(`   - Start time: ${new Date(this.sessionStartTime).toLocaleTimeString()}`);
            console.log(`   - Active: ${this.isRunning}`);
            console.log(`   - Submit count: ${this.submitCount}`);
        } catch (error) {
            console.error(`‚ùå Error saving session data: ${error.message}`);
        }
    }

    async restoreSession() {
        try {
            const sessionData = await chrome.storage.local.get([
                'sessionStartTime', 'sessionActive', 'submitCount'
            ]);

            if (sessionData.sessionActive && sessionData.sessionStartTime) {
                this.sessionStartTime = sessionData.sessionStartTime;
                this.submitCount = sessionData.submitCount || 0;
                this.log(`üîÑ Restored session: start=${this.sessionStartTime}, count=${this.submitCount}`);
                
                // Send restored state to popup
                this.sendStatusUpdate({
                    submitCount: this.submitCount,
                    sessionDuration: Date.now() - this.sessionStartTime,
                    isRunning: false // Not running until explicitly started
                });
            }
        } catch (error) {
            this.log(`‚ùå Error restoring session: ${error.message}`, 'error');
        }
    }

    setupMessageListener() {
        chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
            this.handleMessage(request, sender, sendResponse);
            return true; // Keep message channel open for async response
        });
    }

    async handleMessage(request, sender, sendResponse) {
        try {
            this.log(`üì® Received message: ${request.action}`);
            this.log(`üìã Message data: ${JSON.stringify(request.data)}`);
            
            switch (request.action) {
                case 'fillForm':
                case 'startFilling':
                    // Handle both action names for compatibility
                    const formData = request.data || request.settings;
                    
                    if (!formData) {
                        this.log('‚ùå No form data provided', 'error');
                        sendResponse({ success: false, message: 'No form data provided' });
                        break;
                    }
                    
                    // Initialize session start time and save to storage
                    if (!this.sessionStartTime) {
                        this.sessionStartTime = Date.now();
                        this.isRunning = true; // Mark as running when starting
                        console.log(`üéØ Starting new session at: ${new Date(this.sessionStartTime).toLocaleTimeString()}`);
                        await this.saveSessionToStorage();
                    } else {
                        console.log(`üîÑ Continuing existing session from: ${new Date(this.sessionStartTime).toLocaleTimeString()}`);
                    }
                    
                    this.currentFormData = formData;
                    
                    // Map autoSubmitAnother to autoSubmit for backward compatibility
                    if (this.currentFormData.autoSubmitAnother !== undefined) {
                        this.currentFormData.autoSubmit = this.currentFormData.autoSubmitAnother;
                    }
                    
                    this.log(`üéØ Starting form fill with data: ${JSON.stringify(this.currentFormData)}`);
                    
                    // Debug rating settings
                    this.log(`üéØ Rating settings - Min: ${this.currentFormData.ratingMin}, Max: ${this.currentFormData.ratingMax}`);
                    
                    const result = await this.startFilling();
                    this.log(`üìä Fill result: ${JSON.stringify(result)}`);
                    sendResponse({ success: result.success, message: result.message });
                    break;
                
                case 'stopFilling':
                    this.isRunning = false;
                    this.log('üõë Form filling stopped by user');
                    sendResponse({ success: true, message: 'Filling stopped' });
                    break;
                
                case 'ping':
                    sendResponse({ success: true, message: 'Content script is active' });
                    break;
                
                default:
                    sendResponse({ success: false, message: 'Unknown action' });
            }
        } catch (error) {
            this.log(`Error handling message: ${error.message}`, 'error');
            sendResponse({ success: false, message: error.message });
        }
    }

    async startFilling() {
        if (this.isRunning) {
            this.log('‚ö†Ô∏è Form filling already in progress', 'warning');
            return { success: false, message: 'Already running' };
        }

        try {
            this.isRunning = true;
            this.log('üöÄ Starting form filling process...');
            this.log(`üìã Form data received: ${JSON.stringify(this.currentFormData)}`);
            
            // Validate we're on a Microsoft Forms page
            const isValid = this.isValidFormsPage();
            this.log(`üîç Page validation result: ${isValid}`);
            
            if (!isValid) {
                throw new Error('Not a valid Microsoft Forms page. Current URL: ' + window.location.href);
            }

            let cycleCount = 0;
            // Handle different property names from popup settings
            const maxCycles = this.currentFormData.repeatCount || 
                            this.currentFormData.maxFormSubmissions;
            
            this.log(`üéØ Max cycles configured: ${maxCycles} (repeatCount=${this.currentFormData.repeatCount}, maxFormSubmissions=${this.currentFormData.maxFormSubmissions})`);
            
            // If maxFormSubmissions is 0 or undefined, it means unlimited, so set a reasonable limit
            const effectiveMaxCycles = (maxCycles === 0 || maxCycles === undefined) ? Number.MAX_SAFE_INTEGER : maxCycles;
            
            while (cycleCount < effectiveMaxCycles && this.isRunning) {
                this.log(`üîÑ Starting fill cycle ${cycleCount + 1}/${effectiveMaxCycles}`);
                
                try {
                    const fillResult = await this.fillCurrentForm();
                    if (!fillResult) {
                        throw new Error('Form filling failed');
                    }
                    
                    cycleCount++;
                    
                    // If this is not the last cycle, try to submit another response
                    if (cycleCount < effectiveMaxCycles && this.currentFormData.autoSubmit) {
                        this.log('üîÑ Attempting to submit another response...');
                        const submitAnotherResult = await this.clickSubmitAnother();
                        
                        if (!submitAnotherResult) {
                            this.log('‚ö†Ô∏è Could not click "Submit another response", stopping cycles');
                            break;
                        }
                        
                        // Wait for new form to load after clicking submit another
                        this.log('‚è≥ Waiting for new form to load...');
                        await this.waitForFormToLoad();
                    }
                } catch (fillError) {
                    this.log(`‚ùå Error in fill cycle ${cycleCount + 1}: ${fillError.message}`, 'error');
                    
                    // Decide whether to continue or break based on error severity
                    if (fillError.message.includes('Not a valid Microsoft Forms page') || 
                        fillError.message.includes('No questions found')) {
                        throw fillError; // Critical error, stop completely
                    }
                    
                    // Non-critical error, continue with next cycle but log it
                    this.log('üîÑ Continuing to next cycle despite error', 'warning');
                }
            }
            
            this.log(`‚úÖ Completed ${cycleCount} form filling cycles`);
            
            // Mark session as completed in storage
            await chrome.storage.local.set({
                sessionActive: false,
                finalSessionDuration: this.sessionStartTime ? Date.now() - this.sessionStartTime : 0
            });

            // Send completion status to popup
            chrome.runtime.sendMessage({
                type: 'status_update',
                data: {
                    type: 'success',
                    message: `‚úÖ Ho√†n th√†nh! ƒê√£ ƒëi·ªÅn ${cycleCount} form th√†nh c√¥ng`,
                    isCompleted: true,
                    cycleCount: cycleCount
                }
            }).catch(err => console.log('Popup closed'));
            
            return { success: true, message: `Completed ${cycleCount} cycles successfully` };
            
        } catch (error) {
            this.log(`‚ùå Form filling error: ${error.message}`, 'error');
            
            // Mark session as completed with error in storage
            await chrome.storage.local.set({
                sessionActive: false,
                finalSessionDuration: this.sessionStartTime ? Date.now() - this.sessionStartTime : 0
            });

            // Send error status to popup
            chrome.runtime.sendMessage({
                type: 'status_update',
                data: {
                    type: 'error',
                    message: `‚ùå L·ªói: ${error.message}`,
                    isCompleted: true
                }
            }).catch(err => console.log('Popup closed'));
            
            return { success: false, message: error.message };
        } finally {
            this.isRunning = false;
            // Save final state
            try {
                await this.saveSessionToStorage();
            } catch (saveError) {
                this.log(`‚ùå Error saving final session: ${saveError.message}`, 'error');
            }
        }
    }

    isValidFormsPage() {
        const validDomains = [
            'forms.office.com',
            'forms.microsoft.com',
            'forms.office365.com',
            'forms.cloud.microsoft'
        ];
        
        const currentDomain = window.location.hostname;
        const isValid = validDomains.some(domain => currentDomain.includes(domain));
        
        this.log(`üîç Page validation: ${currentDomain} - ${isValid ? 'Valid' : 'Invalid'}`);
        return isValid;
    }

    async fillCurrentForm() {
        try {
            this.log('üìù Starting form fill process...');
            this.log(`üåê Current URL: ${window.location.href}`);
            this.log(`üìÑ Document ready state: ${document.readyState}`);
            
            // Wait for form to be fully loaded
            this.log('‚è≥ Waiting for form to load...');
            await this.waitForFormLoad();
            
            // Get all questions with validation
            this.log('üîç Searching for questions...');
            let questions;
            try {
                questions = await this.getAllQuestions();
            } catch (questionError) {
                this.log(`‚ùå Error getting questions: ${questionError.message}`, 'error');
                throw new Error(`Failed to detect form questions: ${questionError.message}`);
            }
            
            this.log(`üìã Found ${questions.length} questions to process`);
            
            if (questions.length === 0) {
                this.log('‚ùå No questions found. Analyzing page structure...', 'error');
                this.logPageStructure();
                throw new Error('No questions found on the form. Check if the page has loaded correctly.');
            }
            
            // Fill each question with error handling
            for (let i = 0; i < questions.length; i++) {
                if (!this.isRunning) break;
                
                const question = questions[i];
                this.log(`üìù Processing question ${i + 1}/${questions.length}: ${question.type}`);
                
                try {
                    await this.fillQuestion(question);
                    await this.delay(300, 800); // Random delay between questions
                } catch (questionError) {
                    this.log(`‚ùå Error filling question ${i + 1}: ${questionError.message}`, 'error');
                    // Continue with other questions instead of failing completely
                    continue;
                }
            }
            
            // After filling all questions on current page, check for navigation
            this.log('üîç All questions filled, checking for navigation options...');
            const navigationResult = await this.proceedToNext();
            
            if (navigationResult.success) {
                if (navigationResult.type === 'next') {
                    this.log('üìÑ Successfully navigated to next page');
                    
                    // Reset state for new page
                    await this.resetPageState();
                    
                    // Continue filling on new page (recursive call)
                    this.log('üîÑ Continuing form fill on new page...');
                    return await this.fillCurrentForm();
                    
                } else if (navigationResult.type === 'submit') {
                    this.log('üéâ Form submitted successfully');
                    return true;
                }
            } else {
                // No navigation buttons found - try manual submit if auto-submit enabled
                if (this.currentFormData.autoSubmit) {
                    this.log('üì§ No navigation buttons found, attempting manual submit...');
                    
                    // Enhanced comprehensive validation check before submit
                    await this.sleep(1000); // Give form time to update and process
                    
                    let validationResult;
                    try {
                        validationResult = this.performComprehensiveValidation();
                    } catch (validationError) {
                        this.log(`‚ùå Validation check failed: ${validationError.message}`, 'error');
                        // Continue with submit attempt
                        validationResult = { isValid: true, errors: [], warnings: [] };
                    }
                    
                    if (!validationResult.isValid) {
                        this.log(`‚ö†Ô∏è Form validation issues detected (${validationResult.errors.length} issues):`, 'warning');
                        validationResult.errors.forEach(error => this.log(`  ‚Ä¢ ${error}`, 'warning'));
                        
                        // Check if errors are critical or can be ignored
                        const criticalErrors = validationResult.errors.filter(error => 
                            error.toLowerCase().includes('required') || 
                            error.toLowerCase().includes('mandatory') ||
                            error.toLowerCase().includes('must')
                        );
                        
                        if (criticalErrors.length > 0) {
                            this.log(`‚ùå Critical validation errors found, cannot submit:`, 'error');
                            criticalErrors.forEach(error => this.log(`  ‚Ä¢ ${error}`, 'error'));
                            throw new Error(`Critical validation errors: ${criticalErrors.join(', ')}`);
                        } else {
                            this.log('üîÑ Non-critical validation issues, proceeding with submit');
                        }
                    } else {
                        this.log(`‚úÖ Form validation passed: ${validationResult.successMessage}`, 'success');
                    }
                    
                    try {
                        await this.submitForm();
                        return true;
                    } catch (submitError) {
                        this.log(`‚ö†Ô∏è Manual submit failed: ${submitError.message}`, 'warning');
                        this.log('‚ÑπÔ∏è Form may be complete or require manual intervention');
                        return true; // Consider it successful since questions were filled
                    }
                } else {
                    this.log('‚ÑπÔ∏è Auto-submit disabled, form filling complete');
                    return true;
                }
            }
            
            return true;
            
        } catch (error) {
            this.log(`‚ùå Error in form filling loop: ${error.message}`, 'error');
            throw error;
        }
    }

    async waitForFormLoad() {
        this.log('‚è≥ Waiting for form to load...');
        
        let attempts = 0;
        const maxAttempts = 30; // 15 seconds max wait
        
        while (attempts < maxAttempts) {
            const questions = document.querySelectorAll('[role="radiogroup"], [data-automation-id="questionItem"], input[type="radio"], input[type="checkbox"]');
            
            this.log(`üîÑ Attempt ${attempts + 1}/${maxAttempts}: Found ${questions.length} form elements`);
            
            if (questions.length > 0) {
                this.log(`‚úÖ Form loaded with ${questions.length} interactive elements`);
                await this.sleep(1000); // Extra wait for full rendering
                return;
            }
            
            // Check if page is still loading
            if (document.readyState !== 'complete') {
                this.log(`üìÑ Document still loading... (${document.readyState})`);
            }
            
            await this.sleep(500);
            attempts++;
        }
        
        this.log('‚ö†Ô∏è Form load timeout - analyzing current page state', 'warning');
        this.logPageStructure();
    }

    async getAllQuestions() {
        this.log('üîç SMART question detection starting...');
        
        // Clear processed questions if user manually triggered restart
        if (this.shouldResetProcessedQuestions()) {
            this.log('üîÑ Resetting processed questions for fresh start...');
            this.processedQuestions.clear();
        }
        
        // Use primary strategy first - most reliable
        let allQuestions = this.detectStandardQuestions();
        
        // Only use fallback strategies if primary doesn't find enough
        if (allQuestions.length === 0) {
            this.log('‚ö†Ô∏è No standard questions found, trying fallback strategies...');
            allQuestions = this.detectFallbackQuestions();
        }
        
        // Remove duplicates and invalid questions
        allQuestions = this.cleanAndValidateQuestions(allQuestions);
        
        // Sort by priority and DOM position
        allQuestions = this.sortQuestionsByPriority(allQuestions);
        
        // Filter out processed questions (but allow re-detection if needed)
        const unprocessedQuestions = this.filterUnprocessedQuestions(allQuestions);
        
        this.log(`üìä FINAL: ${allQuestions.length} total questions, ${unprocessedQuestions.length} ready to process`);
        
        return unprocessedQuestions;
    }

    shouldResetProcessedQuestions() {
        // Reset if this is a fresh manual trigger (not from page navigation)
        const now = Date.now();
        const timeSinceLastReset = now - (this.lastResetTime || 0);
        
        // Reset if it's been more than 30 seconds since last activity
        // OR if user manually clicked the extension
        if (timeSinceLastReset > 30000) {
            this.lastResetTime = now;
            return true;
        }
        
        return false;
    }

    detectStandardQuestions() {
        const questions = [];
        
        // Primary strategy: Microsoft Forms standard question items
        const questionItems = document.querySelectorAll('[data-automation-id="questionItem"]');
        this.log(`üìä Primary detection: ${questionItems.length} standard question items`);
        
        for (const element of questionItems) {
            if (!this.isQuestionElementReady(element)) continue;
            
            const questionType = this.identifyQuestionType(element);
            if (questionType) {
                const questionId = this.generateQuestionId(element);
                
                // Check for duplicates
                if (!questions.some(q => q.id === questionId)) {
                    questions.push({
                        element: element,
                        type: questionType,
                        id: questionId,
                        priority: this.getQuestionPriority(questionType, element),
                        isRequired: this.isQuestionRequired(element),
                        source: 'standard'
                    });
                    
                    this.log(`‚úÖ Standard question: ${questionType} (ID: ${questionId.substring(0, 12)}...)`);
                }
            }
        }
        
        return questions;
    }

    detectFallbackQuestions() {
        const questions = [];
        
        this.log('üîÑ Using fallback detection strategies...');
        
        // Strategy 1: Radio groups that might be standalone
        const radioGroups = document.querySelectorAll('[role="radiogroup"]');
        this.log(`üìä Fallback 1: ${radioGroups.length} radio groups`);
        
        for (const element of radioGroups) {
            // Skip if it's already inside a standard question item
            if (element.closest('[data-automation-id="questionItem"]')) continue;
            
            if (this.isQuestionElementReady(element)) {
                const questionId = this.generateQuestionId(element);
                
                if (!questions.some(q => q.id === questionId)) {
                    questions.push({
                        element: element,
                        type: 'radio',
                        id: questionId,
                        priority: 2,
                        isRequired: this.isQuestionRequired(element),
                        source: 'radiogroup'
                    });
                    
                    this.log(`‚úÖ Fallback radio group: ${questionId.substring(0, 12)}...`);
                }
            }
        }
        
        // Strategy 2: Matrix/Likert questions
        const matrixQuestions = this.detectMatrixQuestions();
        questions.push(...matrixQuestions);
        
        return questions;
    }

    detectMatrixQuestions() {
        const matrixQuestions = [];
        
        // Look for Likert scale containers
        const likertContainers = document.querySelectorAll('[data-automation-id*="likert"], [data-automation-id*="matrix"]');
        
        for (const container of likertContainers) {
            // Skip if already processed or inside standard question
            if (container.closest('[data-automation-id="questionItem"]')) continue;
            
            const radioInputs = container.querySelectorAll('input[type="radio"]');
            if (radioInputs.length >= 5) { // Likely a Likert scale
                const questionId = this.generateQuestionId(container);
                
                if (!matrixQuestions.some(q => q.id === questionId)) {
                    matrixQuestions.push({
                        element: container,
                        type: 'matrix',
                        id: questionId,
                        priority: 4,
                        isRequired: this.isQuestionRequired(container),
                        source: 'matrix'
                    });
                    
                    this.log(`‚úÖ Matrix question detected: ${questionId.substring(0, 12)}... (${radioInputs.length} inputs)`);
                }
            }
        }
        
        return matrixQuestions;
    }

    cleanAndValidateQuestions(questions) {
        // Remove duplicates based on element reference and ID
        const cleanQuestions = [];
        const seenElements = new Set();
        const seenIds = new Set();
        
        for (const question of questions) {
            // Skip if we've seen this element or ID
            if (seenElements.has(question.element) || seenIds.has(question.id)) {
                continue;
            }
            
            // Validate question is still in DOM and ready
            if (document.contains(question.element) && this.isQuestionElementReady(question.element)) {
                cleanQuestions.push(question);
                seenElements.add(question.element);
                seenIds.add(question.id);
            }
        }
        
        this.log(`üßπ Cleaned questions: ${questions.length} ‚Üí ${cleanQuestions.length} (removed ${questions.length - cleanQuestions.length} duplicates/invalid)`);
        
        return cleanQuestions;
    }

    sortQuestionsByPriority(questions) {
        return questions.sort((a, b) => {
            // First sort by required status
            if (a.isRequired !== b.isRequired) {
                return b.isRequired - a.isRequired;
            }
            
            // Then by priority
            if (a.priority !== b.priority) {
                return b.priority - a.priority;
            }
            
            // Finally by DOM position
            const aRect = a.element.getBoundingClientRect();
            const bRect = b.element.getBoundingClientRect();
            
            return aRect.top - bRect.top;
        });
    }

    filterUnprocessedQuestions(allQuestions) {
        const unprocessedQuestions = [];
        
        for (const question of allQuestions) {
            const isProcessed = this.processedQuestions.has(question.id);
            const isStillAnswered = this.isQuestionStillAnswered(question);
            
            if (isProcessed && isStillAnswered) {
                // Question was processed and is still answered - skip
                continue;
            } else if (isProcessed && !isStillAnswered) {
                // Question was processed but answer is gone - re-process
                this.log(`ÔøΩ Re-processing question with lost answer: ${question.id}`);
                this.processedQuestions.delete(question.id);
                unprocessedQuestions.push(question);
            } else {
                // New unprocessed question
                unprocessedQuestions.push(question);
            }
        }
        
        return unprocessedQuestions;
    }

    isQuestionStillAnswered(question) {
        try {
            return this.isQuestionAnswered(question.element);
        } catch (error) {
            // If we can't determine, assume it needs re-processing
            return false;
        }
    }

    findOrphanedFormControls() {
        const orphanedControls = [];
        
        try {
            // Look for form controls that might not be inside proper question containers  
            const formControlSelectors = [
                'input[type="radio"]',
                'input[type="checkbox"]', 
                'input[type="text"]',
                'textarea',
                'select',
                '[role="slider"]'
            ];
            
            formControlSelectors.forEach(selector => {
                const controls = document.querySelectorAll(selector);
                
                for (const control of controls) {
                    // Check if this control is already inside a detected question container
                    const parentQuestion = control.closest(`
                        [data-automation-id="questionItem"], 
                        .office-form-question, 
                        [data-automation-id="question"],
                        [role="radiogroup"],
                        .question-container
                    `);
                    
                    if (!parentQuestion && this.isElementVisible(control)) {
                        // This is an orphaned control, find or create appropriate container
                        const wrapper = this.findOrCreateControlContainer(control);
                        if (wrapper && !orphanedControls.includes(wrapper)) {
                            orphanedControls.push(wrapper);
                            this.log(`üîç Found orphaned form control: ${control.type || control.tagName}`);
                        }
                    }
                }
            });
        } catch (error) {
            this.log(`‚ùå Error finding orphaned controls: ${error.message}`, 'error');
        }
        
        return orphanedControls;
    }

    findOrCreateControlContainer(control) {
        try {
            // Try to find a logical container (like a parent div with question-like attributes)
            let container = control.closest('div[aria-labelledby], div.form-group, fieldset');
            
            if (!container) {
                // Look for a parent that contains question text
                let parent = control.parentElement;
                while (parent && parent !== document.body) {
                    const text = parent.textContent?.trim();
                    if (text && text.length > 10 && text.length < 500 && text.includes('?')) {
                        container = parent;
                        break;
                    }
                    parent = parent.parentElement;
                }
            }
            
            if (!container) {
                // Last resort: create a synthetic container
                container = document.createElement('div');
                container.setAttribute('data-synthetic-question', 'true');
                container.setAttribute('data-original-control', control.id || control.name || 'unnamed');
                
                // Insert container before the control
                control.parentNode?.insertBefore(container, control);
                container.appendChild(control);
            }
            
            return container;
        } catch (error) {
            this.log(`‚ùå Error creating control container: ${error.message}`, 'error');
            return null;
        }
    }

    findTableBasedQuestions() {
        const tableQuestions = [];
        
        try {
            // Look for tables that contain form controls (Likert scales, matrices)
            const tables = document.querySelectorAll('table, [role="table"], .table-container');
            
            for (const table of tables) {
                const formControls = table.querySelectorAll('input[type="radio"], input[type="checkbox"], select');
                
                if (formControls.length > 0) {
                    // This table contains form controls, treat it as a question
                    const existingContainer = table.closest('[data-automation-id="questionItem"], .office-form-question');
                    
                    if (!existingContainer) {
                        // This is a standalone table question
                        tableQuestions.push(table);
                        this.log(`üîç Found table-based question: ${formControls.length} controls`);
                    }
                }
            }
        } catch (error) {
            this.log(`‚ùå Error finding table questions: ${error.message}`, 'error');
        }
        
        return tableQuestions;
    }

    isQuestionElementReady(element) {
        try {
            // Enhanced readiness check
            if (!this.isElementVisible(element)) {
                return false;
            }
            
            // Check if question has interactive elements
            const interactiveElements = element.querySelectorAll(`
                input[type="radio"], 
                input[type="checkbox"], 
                input[type="text"], 
                textarea, 
                select,
                [role="slider"]
            `);
            
            if (interactiveElements.length === 0) {
                return false;
            }
            
            // Check if at least one interactive element is ready
            const readyElements = Array.from(interactiveElements).filter(el => {
                return !el.disabled && this.isElementVisible(el);
            });
            
            return readyElements.length > 0;
        } catch (error) {
            this.log(`‚ùå Error checking question readiness: ${error.message}`, 'error');
            return false;
        }
    }

    getQuestionPriority(questionType, element) {
        // Assign priority based on question type and characteristics
        const basePriority = {
            'text': 1,      // Fill text fields first (they're simple)
            'radio': 2,     // Then single-choice questions
            'checkbox': 2,  // Multi-choice at same level
            'select': 2,    // Dropdowns at same level
            'rating': 3,    // Rating scales need special handling
            'matrix': 4     // Matrix questions are most complex
        };
        
        let priority = basePriority[questionType] || 1;
        
        // Boost priority for required questions
        if (this.isQuestionRequired(element)) {
            priority += 5;
        }
        
        // Lower priority for questions with conditional logic (they might depend on other answers)
        if (this.hasConditionalLogic(element)) {
            priority -= 1;
        }
        
        return priority;
    }

    isQuestionRequired(element) {
        try {
            // Check various indicators for required questions
            const requiredIndicators = [
                '[aria-required="true"]',
                '.required',
                '[data-required="true"]',
                '[required]'
            ];
            
            for (const indicator of requiredIndicators) {
                if (element.querySelector(indicator) || element.matches(indicator)) {
                    return true;
                }
            }
            
            // Check for asterisk in question text
            const questionText = this.getQuestionText(element);
            return questionText && questionText.includes('*');
        } catch (error) {
            return false;
        }
    }

    hasConditionalLogic(element) {
        try {
            // Check if question has conditional display logic
            const conditionalIndicators = [
                '[data-conditional]',
                '[data-depends-on]',
                '.conditional-question',
                '[data-condition]'
            ];
            
            for (const indicator of conditionalIndicators) {
                if (element.matches(indicator) || element.querySelector(indicator)) {
                    return true;
                }
            }
            
            // Check if initially hidden (might be conditional)
            const style = window.getComputedStyle(element);
            return style.display === 'none' || style.visibility === 'hidden';
        } catch (error) {
            return false;
        }
    }

    debugQuestionStructure(element) {
        if (!this.debug) return;
        
        try {
            this.log(`üîç DEBUG: Question structure analysis`);
            this.log(`   - Tag: ${element.tagName}`);
            this.log(`   - Classes: ${element.className}`);
            this.log(`   - ID: ${element.id}`);
            
            const dataAttrs = Array.from(element.attributes)
                .filter(attr => attr.name.startsWith('data-'))
                .map(attr => `${attr.name}="${attr.value}"`)
                .join(', ');
            this.log(`   - Data attributes: ${dataAttrs}`);
            
            const inputs = element.querySelectorAll('input, textarea, select');
            this.log(`   - Input elements: ${inputs.length}`);
            this.ensureArray(inputs).forEach((input, index) => {
                this.log(`     ${index + 1}. ${input.tagName}[type="${input.type || 'N/A'}"] - ${input.name || input.id || 'unnamed'}`);
            });
            
            const text = this.getQuestionText(element);
            this.log(`   - Question text: "${text?.substring(0, 100)}..."`);
            
        } catch (error) {
            this.log(`‚ùå Error debugging question structure: ${error.message}`, 'error');
        }
    }

    generateQuestionId(element) {
        // Generate stable, unique ID for question tracking
        
        // Method 1: Use element ID if available
        if (element.id && element.id.trim()) {
            return `id_${element.id}`;
        }
        
        // Method 2: Use question text hash if available
        const questionText = this.getQuestionText(element);
        if (questionText && questionText.length > 5) {
            const hash = this.createStableHash(questionText);
            return `text_${hash}`;
        }
        
        // Method 3: Use element attributes and structure
        const attributeSignature = this.getElementSignature(element);
        if (attributeSignature) {
            const hash = this.createStableHash(attributeSignature);
            return `attr_${hash}`;
        }
        
        // Method 4: Use DOM position as last resort
        const domPosition = this.getElementDOMPosition(element);
        return `pos_${domPosition}`;
    }

    createStableHash(text) {
        // Create a stable hash that's consistent across sessions
        let hash = 0;
        if (text.length === 0) return hash;
        
        for (let i = 0; i < text.length; i++) {
            const char = text.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        
        return Math.abs(hash).toString(36); // Base36 for shorter IDs
    }

    getElementSignature(element) {
        // Create a unique signature from element attributes and structure
        const parts = [];
        
        // Add tag name
        parts.push(element.tagName.toLowerCase());
        
        // Add significant attributes
        const significantAttrs = ['data-automation-id', 'class', 'role', 'aria-label', 'name'];
        for (const attr of significantAttrs) {
            const value = element.getAttribute(attr);
            if (value) {
                parts.push(`${attr}:${value.substring(0, 20)}`);
            }
        }
        
        // Add child element count and types
        const childTypes = Array.from(element.children).map(child => child.tagName.toLowerCase());
        const uniqueChildTypes = [...new Set(childTypes)].sort();
        if (uniqueChildTypes.length > 0) {
            parts.push(`children:${uniqueChildTypes.join(',')}`);
        }
        
        // Add input count if it's a form element
        const inputs = element.querySelectorAll('input, textarea, select');
        if (inputs.length > 0) {
            const inputTypes = Array.from(inputs).map(input => input.type || input.tagName.toLowerCase());
            const uniqueInputTypes = [...new Set(inputTypes)].sort();
            parts.push(`inputs:${inputs.length}:${uniqueInputTypes.join(',')}`);
        }
        
        return parts.join('|');
    }

    getElementDOMPosition(element) {
        // Get a stable position identifier based on DOM structure
        let position = 0;
        let current = element;
        
        // Walk up the tree and calculate position
        while (current && current.parentElement) {
            const siblings = Array.from(current.parentElement.children);
            position += siblings.indexOf(current);
            current = current.parentElement;
            
            // Limit depth to avoid huge numbers
            if (position > 10000) break;
        }
        
        // Add element rect for additional uniqueness
        const rect = element.getBoundingClientRect();
        const rectSignature = `${Math.round(rect.top)}_${Math.round(rect.left)}_${Math.round(rect.width)}_${Math.round(rect.height)}`;
        
        return `${position}_${rectSignature}`;
    }

    getElementXPath(element) {
        // Simple XPath generation for element identification
        const parts = [];
        let current = element;
        
        while (current && current.nodeType === Node.ELEMENT_NODE) {
            let selector = current.tagName.toLowerCase();
            if (current.id) {
                selector += `[@id="${current.id}"]`;
                parts.unshift(selector);
                break;
            } else if (current.className) {
                selector += `[@class="${current.className.replace(/\s+/g, ' ').trim()}"]`;
            }
            
            // Add position if needed to make unique
            const siblings = Array.from(current.parentNode?.children || []);
            const sameTagSiblings = siblings.filter(sibling => sibling.tagName === current.tagName);
            if (sameTagSiblings.length > 1) {
                const index = sameTagSiblings.indexOf(current) + 1;
                selector += `[${index}]`;
            }
            
            parts.unshift(selector);
            current = current.parentNode;
            
            // Limit depth to avoid overly long XPaths
            if (parts.length > 5) break;
        }
        
        return parts.join('/');
    }

    identifyQuestionType(element) {
        // Matrix/Grid questions (Likert scale tables) - Be more precise to avoid false positives
        
        // Method 1: Check for Microsoft Forms specific Likert structure (most reliable) - Updated for new structure
        const likertSubQuestions = element.querySelectorAll('[data-automation-id="likerSubQuestion"]');
        if (likertSubQuestions.length > 0) {
            this.log(`üîç Matrix question detected via likerSubQuestion: ${likertSubQuestions.length} sub-questions`);
            return 'matrix';
        }
        
        // Method 1b: Legacy check for old Likert structure
        const likertStatements = element.querySelectorAll('[data-automation-id="likerStatementTd"]');
        if (likertStatements.length > 0) {
            this.log(`üîç Matrix question detected via likertStatements: ${likertStatements.length}`);
            return 'matrix';
        }
        
        // Method 2: Check for table with multiple radio group rows
        const radioGroupRows = element.querySelectorAll('tr[role="radiogroup"]');
        if (radioGroupRows.length > 1) {
            this.log(`üîç Matrix question detected via radioGroupRows: ${radioGroupRows.length}`);
            return 'matrix';
        }
        
        // Method 3: Check for table with many radio inputs arranged in rows
        const tablesWithRadios = element.querySelectorAll('table');
        for (const table of tablesWithRadios) {
            const tableRows = table.querySelectorAll('tr');
            const radioInputsInTable = table.querySelectorAll('input[type="radio"]');
            
            // Must have multiple rows AND multiple radios (at least 2 rows x 3 options = 6 radios minimum)
            if (tableRows.length >= 2 && radioInputsInTable.length >= 6) {
                // Additional check: radios should be distributed across rows
                let rowsWithRadios = 0;
                for (const row of tableRows) {
                    if (row.querySelectorAll('input[type="radio"]').length > 0) {
                        rowsWithRadios++;
                    }
                }
                
                if (rowsWithRadios >= 2) {
                    this.log(`üîç Matrix question detected via table structure: ${rowsWithRadios} rows with radios, ${radioInputsInTable.length} total radios`);
                    return 'matrix';
                }
            }
        }
        
        // Method 4: Check for multiple radio groups (non-table structure)
        const radioGroups = element.querySelectorAll('[role="radiogroup"]');
        if (radioGroups.length > 1) {
            this.log(`üîç Matrix question detected via multiple radiogroups: ${radioGroups.length}`);
            return 'matrix';
        }
        
        // Method 5: Fallback - check for very high radio count with specific patterns
        const allRadioInputs = element.querySelectorAll('input[type="radio"]');
        if (allRadioInputs.length >= 15) { // Very conservative threshold
            // Additional verification: check if radios are grouped (same name attribute patterns)
            const radioNames = new Set();
            allRadioInputs.forEach(radio => {
                if (radio.name) radioNames.add(radio.name);
            });
            
            // If we have multiple radio groups (different names), it's likely a matrix
            if (radioNames.size >= 3) {
                this.log(`üîç Matrix question detected via high radio count: ${allRadioInputs.length} radios, ${radioNames.size} groups`);
                return 'matrix';
            }
        }
        
        // Rating/Likert scale (single row slider-style)
        if (element.querySelector('[role="slider"], .rating-component')) {
            return 'rating';
        }
        
        // Dropdown
        if (element.querySelector('select')) {
            return 'select';
        }
        
        // Text input
        if (element.querySelector('input[type="text"], textarea')) {
            return 'text';
        }
        
        // Checkboxes
        if (element.querySelector('input[type="checkbox"]')) {
            return 'checkbox';
        }
        
        // Multiple choice (radio buttons) - Check last as matrix also has radio buttons
        if (element.querySelector('input[type="radio"]') || element.getAttribute('role') === 'radiogroup') {
            return 'radio';
        }
        
        return null;
    }

    async fillQuestion(question) {
        try {
            this.log(`üéØ Filling ${question.type} question (index: ${question.index})`);
            
            switch (question.type) {
                case 'radio':
                    await this.fillRadioQuestion(question);
                    break;
                case 'checkbox':
                    await this.fillCheckboxQuestion(question);
                    break;
                case 'text':
                    await this.fillTextQuestion(question);
                    break;
                case 'rating':
                    await this.fillRatingQuestion(question);
                    break;
                case 'select':
                    await this.fillSelectQuestion(question);
                    break;
                case 'matrix':
                    await this.fillMatrixQuestion(question);
                    break;
                default:
                    this.log(`‚ö†Ô∏è Unknown question type: ${question.type}`, 'warning');
            }
            
            // Mark question as processed after successful fill
            const questionId = this.generateQuestionId(question.element);
            this.processedQuestions.add(questionId);
            this.log(`‚úÖ Question marked as processed: ${questionId}`);
            
            await this.delay(200, 500);
            
        } catch (error) {
            this.log(`‚ùå Error filling question: ${error.message}`, 'error');
            
            // Still mark as processed to avoid infinite loops on problematic questions
            const questionId = this.generateQuestionId(question.element);
            this.processedQuestions.add(questionId);
            this.log(`‚ö†Ô∏è Question marked as processed despite error: ${questionId}`);
        }
    }

    async fillRadioQuestion(question) {
        const radioInputs = question.element.querySelectorAll('input[type="radio"]');
        
        if (radioInputs.length === 0) {
            this.log('‚ö†Ô∏è No radio inputs found', 'warning');
            return;
        }
        
        this.log(`üìä Found ${radioInputs.length} radio options`);
        
        // Get user preferences for this question
        const customChoice = this.getCustomChoiceForQuestion(question);
        
        let selectedInput = null;
        
        if (customChoice) {
            this.log(`üéØ Looking for custom choice: "${customChoice}"`);
            
            // Try multiple matching methods
            const matchingMethods = [
                // Method 1: Exact match (case insensitive)
                (label, choice) => label.toLowerCase().trim() === choice.toLowerCase().trim(),
                // Method 2: Label contains choice
                (label, choice) => label.toLowerCase().includes(choice.toLowerCase()),
                // Method 3: Choice contains label (for short answers)
                (label, choice) => choice.toLowerCase().includes(label.toLowerCase()),
                // Method 4: Remove common words and match
                (label, choice) => {
                    const cleanLabel = label.toLowerCase().replace(/[^\w\s]/g, '').trim();
                    const cleanChoice = choice.toLowerCase().replace(/[^\w\s]/g, '').trim();
                    return cleanLabel === cleanChoice || cleanLabel.includes(cleanChoice) || cleanChoice.includes(cleanLabel);
                }
            ];
            
            // Try each matching method
            for (let i = 0; i < matchingMethods.length && !selectedInput; i++) {
                selectedInput = Array.from(radioInputs).find(input => {
                    const label = this.getInputLabel(input);
                    if (!label) return false;
                    
                    const matches = matchingMethods[i](label, customChoice);
                    if (matches) {
                        this.log(`üéØ Method ${i + 1} match: "${label}" ‚Üî "${customChoice}"`);
                    }
                    return matches;
                });
                
                if (selectedInput) {
                    this.log(`‚úÖ Found custom choice match using method ${i + 1}: "${this.getInputLabel(selectedInput)}"`);
                    break;
                }
            }
            
            if (!selectedInput) {
                this.log(`‚ö†Ô∏è No matching option found for custom choice: "${customChoice}"`);
                // Debug: log all available options
                this.log(`üìã Available options:`);
                Array.from(radioInputs).forEach((input, index) => {
                    const label = this.getInputLabel(input);
                    this.log(`   ${index + 1}. "${label}"`);
                });
            }
        }
        
        // If no custom choice found, use selection strategy
        if (!selectedInput) {
            // Check multiple possible strategy keys from different versions
            let strategy = this.currentFormData.selectionStrategy || this.currentFormData.radioStrategy || 'random';
            
            // If avoidOther is explicitly set to true, override the strategy
            if (this.currentFormData.avoidOther === true) {
                strategy = 'avoid_other';
                this.log(`üéØ Overriding strategy to 'avoid_other' due to avoidOther=true`);
            }
                           
            this.log(`üéØ Using selection strategy: ${strategy}`);
            this.log(`üìã Available strategies from form data: selectionStrategy=${this.currentFormData.selectionStrategy}, radioStrategy=${this.currentFormData.radioStrategy}, avoidOther=${this.currentFormData.avoidOther}`);
            
            selectedInput = this.selectByStrategy(radioInputs, strategy);
        }
        
        if (selectedInput) {
            await this.selectRadioChoice(selectedInput);
        } else {
            this.log('‚ùå No suitable radio option found', 'error');
        }
    }

    getCustomChoiceForQuestion(question) {
        // Enhanced custom choice detection with multiple matching strategies
        const questionText = this.getQuestionText(question.element);
        
        if (!questionText) {
            this.log(`‚ö†Ô∏è No question text found for custom choice matching`);
            return null;
        }
        
        this.log(`üîç ENHANCED custom choice search for: "${questionText.substring(0, 80)}..."`);
        
        // Check for special questions (fixed answers) from popup
        if (this.currentFormData.specialQuestions && this.currentFormData.specialQuestions.length > 0) {
            this.log(`ÔøΩ Checking ${this.currentFormData.specialQuestions.length} special questions with enhanced matching:`);
            
            const bestMatch = this.findBestSpecialQuestionMatch(questionText, this.currentFormData.specialQuestions);
            
            if (bestMatch) {
                this.log(`‚úÖ BEST MATCH found: "${bestMatch.specialQuestion.keyword}" ‚Üí "${bestMatch.specialQuestion.answer}" (score: ${bestMatch.score.toFixed(3)}, method: ${bestMatch.method})`);
                return bestMatch.specialQuestion.answer;
            }
            
            this.log(`‚ö†Ô∏è No matching special question found with enhanced matching`);
        }
        
        // Fallback: check for custom fields (legacy support)
        if (this.currentFormData.customFields && this.currentFormData.customFields.length > 0) {
            this.log(`üîÑ Checking ${this.currentFormData.customFields.length} legacy custom fields:`);
            
            for (const field of this.currentFormData.customFields) {
                if (field.question && field.value) {
                    const matchScore = this.calculateTextMatchScore(questionText, field.question);
                    this.log(`   - "${field.question}" ‚Üí "${field.value}" (score: ${matchScore.toFixed(3)})`);
                    
                    if (matchScore > 0.6) { // 60% similarity threshold
                        this.log(`‚úÖ Legacy custom field match: "${field.question}" ‚Üí "${field.value}"`);
                        return field.value;
                    }
                }
            }
        }
        
        return null;
    }

    findBestSpecialQuestionMatch(questionText, specialQuestions) {
        const matches = [];
        
        for (const specialQuestion of specialQuestions) {
            if (!specialQuestion.keyword || !specialQuestion.answer) {
                continue;
            }
            
            // Multiple matching strategies with scoring
            const matchStrategies = [
                {
                    name: 'exact_match',
                    score: this.calculateExactMatch(questionText, specialQuestion.keyword),
                    weight: 1.0
                },
                {
                    name: 'contains_match',
                    score: this.calculateContainsMatch(questionText, specialQuestion.keyword),
                    weight: 0.9
                },
                {
                    name: 'fuzzy_match',
                    score: this.calculateFuzzyMatch(questionText, specialQuestion.keyword),
                    weight: 0.8
                },
                {
                    name: 'word_overlap',
                    score: this.calculateWordOverlap(questionText, specialQuestion.keyword),
                    weight: 0.7
                },
                {
                    name: 'partial_match',
                    score: this.calculatePartialMatch(questionText, specialQuestion.keyword),
                    weight: 0.6
                }
            ];
            
            // Find best strategy for this special question
            const bestStrategy = matchStrategies.reduce((best, current) => {
                const weightedScore = current.score * current.weight;
                const bestWeightedScore = best.score * best.weight;
                return weightedScore > bestWeightedScore ? current : best;
            });
            
            const finalScore = bestStrategy.score * bestStrategy.weight;
            
            this.log(`   - "${specialQuestion.keyword}" ‚Üí "${specialQuestion.answer}" | ${bestStrategy.name}: ${finalScore.toFixed(3)}`);
            
            if (finalScore > 0.5) { // Minimum threshold for consideration
                matches.push({
                    specialQuestion,
                    score: finalScore,
                    method: bestStrategy.name
                });
            }
        }
        
        // Return best match if any
        if (matches.length > 0) {
            matches.sort((a, b) => b.score - a.score);
            return matches[0];
        }
        
        return null;
    }

    calculateExactMatch(text1, text2) {
        const clean1 = this.cleanTextForMatching(text1);
        const clean2 = this.cleanTextForMatching(text2);
        return clean1 === clean2 ? 1.0 : 0.0;
    }

    calculateContainsMatch(questionText, keyword) {
        const cleanQuestion = this.cleanTextForMatching(questionText);
        const cleanKeyword = this.cleanTextForMatching(keyword);
        
        if (cleanQuestion.includes(cleanKeyword)) {
            // Score based on keyword length relative to question length
            return Math.min(1.0, cleanKeyword.length / cleanQuestion.length + 0.5);
        }
        
        // Check reverse containment (keyword contains question parts)
        if (cleanKeyword.includes(cleanQuestion)) {
            return Math.min(1.0, cleanQuestion.length / cleanKeyword.length + 0.3);
        }
        
        return 0.0;
    }

    calculateFuzzyMatch(text1, text2) {
        // Simple Levenshtein distance-based similarity
        const clean1 = this.cleanTextForMatching(text1);
        const clean2 = this.cleanTextForMatching(text2);
        
        const distance = this.levenshteinDistance(clean1, clean2);
        const maxLength = Math.max(clean1.length, clean2.length);
        
        if (maxLength === 0) return 1.0;
        
        return Math.max(0, 1 - distance / maxLength);
    }

    calculateWordOverlap(text1, text2) {
        const words1 = new Set(this.extractSignificantWords(text1));
        const words2 = new Set(this.extractSignificantWords(text2));
        
        if (words1.size === 0 || words2.size === 0) return 0.0;
        
        const intersection = new Set([...words1].filter(word => words2.has(word)));
        const union = new Set([...words1, ...words2]);
        
        return intersection.size / union.size; // Jaccard similarity
    }

    calculatePartialMatch(questionText, keyword) {
        const cleanQuestion = this.cleanTextForMatching(questionText);
        const cleanKeyword = this.cleanTextForMatching(keyword);
        
        // Check if significant portions match
        const keywordWords = cleanKeyword.split(/\s+/);
        const questionWords = cleanQuestion.split(/\s+/);
        
        let matchingWords = 0;
        
        for (const keywordWord of keywordWords) {
            if (keywordWord.length > 2) { // Only consider words longer than 2 chars
                for (const questionWord of questionWords) {
                    if (questionWord.includes(keywordWord) || keywordWord.includes(questionWord)) {
                        matchingWords++;
                        break;
                    }
                }
            }
        }
        
        return keywordWords.length > 0 ? matchingWords / keywordWords.length : 0.0;
    }

    calculateTextMatchScore(text1, text2) {
        // Composite scoring combining multiple methods
        const exactScore = this.calculateExactMatch(text1, text2);
        if (exactScore > 0) return exactScore;
        
        const containsScore = this.calculateContainsMatch(text1, text2);
        const fuzzyScore = this.calculateFuzzyMatch(text1, text2);
        const wordScore = this.calculateWordOverlap(text1, text2);
        const partialScore = this.calculatePartialMatch(text1, text2);
        
        // Weighted average
        return (containsScore * 0.3 + fuzzyScore * 0.3 + wordScore * 0.25 + partialScore * 0.15);
    }

    cleanTextForMatching(text) {
        if (!text) return '';
        
        return text
            .toLowerCase()
            .replace(/[^\w\s]/g, ' ') // Replace punctuation with spaces
            .replace(/\s+/g, ' ')     // Normalize whitespace
            .trim();
    }

    extractSignificantWords(text) {
        if (!text) return [];
        
        // Common stop words to filter out
        const stopWords = new Set([
            'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by',
            'is', 'are', 'was', 'were', 'be', 'been', 'have', 'has', 'had', 'do', 'does', 'did',
            'will', 'would', 'could', 'should', 'may', 'might', 'can', 'this', 'that', 'these', 'those'
        ]);
        
        return this.cleanTextForMatching(text)
            .split(/\s+/)
            .filter(word => word.length > 2 && !stopWords.has(word));
    }

    levenshteinDistance(str1, str2) {
        const matrix = [];
        
        for (let i = 0; i <= str2.length; i++) {
            matrix[i] = [i];
        }
        
        for (let j = 0; j <= str1.length; j++) {
            matrix[0][j] = j;
        }
        
        for (let i = 1; i <= str2.length; i++) {
            for (let j = 1; j <= str1.length; j++) {
                if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                } else {
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j - 1] + 1, // substitution
                        matrix[i][j - 1] + 1,     // insertion
                        matrix[i - 1][j] + 1      // deletion
                    );
                }
            }
        }
        
        return matrix[str2.length][str1.length];
    }

    getQuestionText(element) {
        // Try multiple selectors to get question text
        const textSelectors = [
            '.question-title',
            '[data-automation-id="questionTitle"]',
            '.office-form-question-title',
            'h2', 'h3', 'h4',
            '.text-format-content'
        ];
        
        for (const selector of textSelectors) {
            const textElement = element.querySelector(selector);
            if (textElement && textElement.textContent.trim()) {
                return textElement.textContent.trim();
            }
        }
        
        // Fallback: get first meaningful text
        const allText = element.textContent.trim();
        return allText.split('\n')[0] || allText.substring(0, 100);
    }

    selectByStrategy(inputs, strategy) {
        const visibleInputs = Array.from(inputs).filter(this.isElementVisible.bind(this));
        
        this.log(`üîç selectByStrategy: ${inputs.length} total inputs, ${visibleInputs.length} visible inputs`);
        
        if (visibleInputs.length === 0) {
            this.log('‚ùå No visible inputs found', 'warning');
            return null;
        }
        
        this.log(`üéØ Applying strategy: ${strategy}`);
        
        let selectedInput = null;
        
        // Check if this looks like a rating/Likert scale question
        const isRatingQuestion = this.isRatingScale(visibleInputs);
        this.log(`üîç Rating scale detection result: ${isRatingQuestion}`);
        
        if (isRatingQuestion) {
            const settingsMin = this.currentFormData.ratingMin || 4;
            const settingsMax = this.currentFormData.ratingMax || 5;
            this.log(`üéØ Detected rating/Likert scale - using rating strategy with range ${settingsMin}-${settingsMax}`);
            
            selectedInput = this.selectRatingFromInputsPositional(this.ensureArray(visibleInputs), settingsMin, settingsMax);
            
            if (selectedInput) {
                const selectedRating = Array.from(visibleInputs).indexOf(selectedInput) + 1;
                this.log(`üéØ Selected rating ${selectedRating}/${visibleInputs.length} based on settings`);
            } else {
                this.log('‚ö†Ô∏è Rating selection returned null, falling back to strategy');
            }
        }
        
        // If not a rating question or rating selection failed, use original strategy
        if (!selectedInput) {
            switch (strategy) {
                case 'first':
                    selectedInput = visibleInputs[0];
                    this.log(`üéØ Selected first option: "${this.getInputLabel(selectedInput)}"`);
                    break;
                case 'last':
                    selectedInput = visibleInputs[visibleInputs.length - 1];
                    this.log(`üéØ Selected last option: "${this.getInputLabel(selectedInput)}"`);
                    break;
                case 'middle':
                    selectedInput = visibleInputs[Math.floor(visibleInputs.length / 2)];
                    this.log(`üéØ Selected middle option: "${this.getInputLabel(selectedInput)}"`);
                    break;
                case 'avoid_other':
                    this.log('üîç Calling selectAvoidingOther...');
                    selectedInput = this.selectAvoidingOther(visibleInputs);
                    break;
                case 'random':
                default:
                    selectedInput = visibleInputs[Math.floor(Math.random() * visibleInputs.length)];
                    this.log(`üéØ Selected random option: "${this.getInputLabel(selectedInput)}"`);
                    break;
            }
        }
        
        if (!selectedInput) {
            this.log('‚ùå Strategy returned null - no option selected', 'error');
        }
        
        return selectedInput;
    }

    isRatingScale(inputs) {
        if (inputs.length < 3) {
            this.log(`üîç Not rating scale: too few inputs (${inputs.length})`);
            return false; // Rating scales usually have at least 3 options
        }
        
        // Check if labels are numeric (1, 2, 3, 4, 5) or contain rating-related keywords
        let numericCount = 0;
        let ratingKeywordCount = 0;
        const labelsToCheck = inputs.slice(0, Math.min(5, inputs.length));
        
        this.log(`üîç Checking ${labelsToCheck.length} inputs for rating scale patterns`);
        
        for (const input of labelsToCheck) {
            const label = this.getInputLabel(input);
            this.log(`üîç Input label: "${label}"`);
            
            if (label) {
                const cleanLabel = label.trim().toLowerCase();
                
                // Check for pure numeric labels (1, 2, 3, etc.)
                if (/^\d+$/.test(cleanLabel)) {
                    numericCount++;
                    this.log(`üìä Found numeric label: ${cleanLabel}`);
                }
                
                // Check for rating-related keywords
                const ratingKeywords = [
                    'strongly disagree', 'disagree', 'neutral', 'agree', 'strongly agree',
                    'r·∫•t kh√¥ng ƒë·ªìng √Ω', 'kh√¥ng ƒë·ªìng √Ω', 'trung t√≠nh', 'ƒë·ªìng √Ω', 'r·∫•t ƒë·ªìng √Ω',
                    'very dissatisfied', 'dissatisfied', 'satisfied', 'very satisfied',
                    'r·∫•t kh√¥ng h√†i l√≤ng', 'kh√¥ng h√†i l√≤ng', 'h√†i l√≤ng', 'r·∫•t h√†i l√≤ng',
                    'never', 'rarely', 'sometimes', 'often', 'always',
                    'kh√¥ng bao gi·ªù', 'hi·∫øm khi', 'th·ªânh tho·∫£ng', 'th∆∞·ªùng xuy√™n', 'lu√¥n lu√¥n',
                    'poor', 'fair', 'good', 'very good', 'excellent',
                    'k√©m', 't·∫°m ƒë∆∞·ª£c', 't·ªët', 'r·∫•t t·ªët', 'xu·∫•t s·∫Øc'
                ];
                
                const matchedKeyword = ratingKeywords.find(keyword => cleanLabel.includes(keyword));
                if (matchedKeyword) {
                    ratingKeywordCount++;
                    this.log(`üîç Found rating keyword: "${matchedKeyword}" in "${cleanLabel}"`);
                }
            }
        }
        
        // It's a rating scale if:
        // 1. Most labels are numeric (like 1, 2, 3, 4, 5)
        // 2. Contains rating-related keywords in sequence
        const isNumericScale = numericCount >= Math.min(3, inputs.length * 0.6);
        const hasRatingKeywords = ratingKeywordCount >= Math.min(2, inputs.length * 0.4);
        
        const isRating = isNumericScale || hasRatingKeywords;
        
        this.log(`üîç Rating scale analysis: numeric=${numericCount}/${inputs.length} (threshold: ${Math.min(3, inputs.length * 0.6)}), keywords=${ratingKeywordCount}/${inputs.length} (threshold: ${Math.min(2, inputs.length * 0.4)})`);
        this.log(`üéØ Final rating scale result: ${isRating} (numeric: ${isNumericScale}, keywords: ${hasRatingKeywords})`);
        
        return isRating;
    }

    selectAvoidingOther(inputs) {
        // Try to avoid "Other", "Kh√°c", "N/A" options using multiple methods
        const avoidKeywords = ['other', 'kh√°c', 'n/a', 'kh√¥ng c√≥', 'kh√¥ng', 'none', 'kh√°c (xin ghi r√µ)', 'specify', 'chi ti·∫øt'];
        
        this.log(`üîç Analyzing ${inputs.length} inputs to avoid "other" options`);
        
        const inputsArray = this.ensureArray(inputs);
        const preferredInputs = inputsArray.filter(input => {
            const label = this.getInputLabel(input).toLowerCase();
            
            // Method 1: Check label text
            const hasOtherKeyword = avoidKeywords.some(keyword => label.includes(keyword));
            
            // Method 2: Check if this is likely an "Other" option by DOM structure
            let isLikelyOther = false;
            
            // Check if there's a text input nearby (common for "Other" options)
            const parent = input.parentElement;
            const hasTextInput = parent && (
                parent.querySelector('input[type="text"]') ||
                parent.querySelector('textarea') ||
                parent.nextElementSibling?.querySelector('input[type="text"]') ||
                parent.nextElementSibling?.querySelector('textarea')
            );
            
            // Check for common "Other" attributes or classes
            const hasOtherAttributes = 
                input.value?.toLowerCase().includes('other') ||
                input.id?.toLowerCase().includes('other') ||
                input.className?.toLowerCase().includes('other') ||
                parent?.className?.toLowerCase().includes('other');
            
            // Check if this is the last option (often "Other" is placed last)
            const allInputsInGroup = inputs;
            const isLastOption = allInputsInGroup.indexOf(input) === allInputsInGroup.length - 1;
            
            isLikelyOther = hasTextInput || hasOtherAttributes || (isLastOption && hasOtherKeyword);
            
            const shouldAvoid = hasOtherKeyword || isLikelyOther;
            
            this.log(`üìã Option: "${label}" - Text:${hasOtherKeyword ? 'OTHER' : 'OK'}, Structure:${isLikelyOther ? 'OTHER' : 'OK'} -> ${shouldAvoid ? 'AVOIDED' : 'OK'}`);
            
            return !shouldAvoid;
        });
        
        this.log(`‚úÖ Found ${preferredInputs.length} preferred options out of ${inputs.length} total`);
        
        if (preferredInputs.length > 0) {
            const selected = preferredInputs[Math.floor(Math.random() * preferredInputs.length)];
            this.log(`üéØ Selected preferred option: "${this.getInputLabel(selected)}"`);
            return selected;
        }
        
        // If all options are flagged as "other", select the first non-last option
        this.log(`‚ö†Ô∏è All options flagged as "other", trying to select non-last option...`);
        if (inputs.length > 1) {
            // Select from first n-1 options (avoid the last one which is most likely "Other")
            const nonLastOptions = inputs.slice(0, -1);
            const selected = nonLastOptions[Math.floor(Math.random() * nonLastOptions.length)];
            this.log(`üéØ Selected non-last option: "${this.getInputLabel(selected)}"`);
            return selected;
        }
        
        // Last resort - pick randomly
        const selected = inputs[Math.floor(Math.random() * inputs.length)];
        this.log(`‚ö†Ô∏è Last resort random selection: "${this.getInputLabel(selected)}"`);
        return selected;
    }

    getInputLabel(input) {
        let labelText = '';
        
        // Method 1: Check aria-label first
        labelText = input.getAttribute('aria-label');
        if (labelText && labelText.trim()) {
            return labelText.trim();
        }
        
        // Method 2: Try closest label element
        const labelElement = input.closest('label');
        if (labelElement) {
            labelText = labelElement.textContent.trim();
            if (labelText) return labelText;
        }
        
        // Method 3: Try label[for] association
        if (input.id) {
            const associatedLabel = document.querySelector(`label[for="${input.id}"]`);
            if (associatedLabel) {
                labelText = associatedLabel.textContent.trim();
                if (labelText) return labelText;
            }
        }
        
        // Method 4: Microsoft Forms specific - look for span siblings
        const parent = input.parentElement;
        if (parent) {
            // Look for span elements with text content
            const spans = parent.querySelectorAll('span');
            for (const span of spans) {
                const text = span.textContent.trim();
                if (text && text !== input.value && !span.contains(input)) {
                    labelText = text;
                    break;
                }
            }
            if (labelText) return labelText;
        }
        
        // Method 5: Try parent's text content (excluding input)
        if (parent) {
            let parentText = parent.textContent.trim();
            // Remove input value from parent text if it exists
            if (input.value) {
                parentText = parentText.replace(input.value, '').trim();
            }
            if (parentText) {
                labelText = parentText;
            }
        }
        
        // Method 6: Look in grandparent or higher ancestors
        let ancestor = parent?.parentElement;
        let attempts = 0;
        while (ancestor && attempts < 3 && !labelText) {
            const ancestorSpans = ancestor.querySelectorAll('span');
            for (const span of ancestorSpans) {
                const text = span.textContent.trim();
                if (text && 
                    text !== input.value && 
                    !span.contains(input) && 
                    text.length > 1 && 
                    text.length < 200) { // Reasonable text length
                    labelText = text;
                    break;
                }
            }
            ancestor = ancestor.parentElement;
            attempts++;
        }
        
        // Method 7: Try div siblings with text
        if (!labelText && parent) {
            const siblings = Array.from(parent.parentElement?.children || []);
            for (const sibling of siblings) {
                if (sibling !== parent && sibling.textContent.trim() && !sibling.contains(input)) {
                    const text = sibling.textContent.trim();
                    if (text.length > 1 && text.length < 200) {
                        labelText = text;
                        break;
                    }
                }
            }
        }
        
        // Method 8: Last resort - use input value or placeholder
        if (!labelText) {
            labelText = input.value || input.placeholder || input.getAttribute('title') || '';
        }
        
        // Clean up the label text
        if (labelText) {
            labelText = labelText.trim();
            // Remove common artifacts
            labelText = labelText.replace(/^\s*\|\s*/, '').trim(); // Remove leading |
            labelText = labelText.replace(/\s+/g, ' '); // Normalize whitespace
        }
        
        return labelText || 'Unknown Option';
    }

    async selectRadioChoice(input) {
        try {
            if (!input) {
                this.log('‚ùå Input element is null/undefined', 'error');
                return false;
            }

            this.log(`üéØ Selecting radio choice: "${this.getInputLabel(input)}"`);
            
            // Scroll into view
            if (input.scrollIntoView) {
                input.scrollIntoView({ behavior: 'smooth', block: 'center' });
                await this.sleep(300);
            }
            
            // Try multiple click methods
            const clickMethods = [
                () => input.click(),
                () => input.focus() && input.click(),
                () => {
                    const label = input.closest('label') || input.parentElement;
                    if (label) label.click();
                },
                () => input.dispatchEvent(new MouseEvent('click', { bubbles: true })),
                () => {
                    input.checked = true;
                    input.dispatchEvent(new Event('change', { bubbles: true }));
                },
                () => {
                    const parent = input.closest('[role="radio"]');
                    if (parent) parent.click();
                }
            ];
            
            for (let i = 0; i < clickMethods.length; i++) {
                try {
                    this.log(`üîÑ Trying click method ${i + 1}`);
                    clickMethods[i]();
                    await this.sleep(200);
                    
                    if (input.checked) {
                        this.log(`‚úÖ Successfully selected radio option using method ${i + 1}`);
                        return true;
                    }
                } catch (error) {
                    this.log(`‚ö†Ô∏è Click method ${i + 1} failed: ${error.message}`);
                }
            }
            
            this.log('‚ùå All click methods failed for radio selection', 'error');
            return false;
            
        } catch (error) {
            this.log(`‚ùå Error selecting radio choice: ${error.message}`, 'error');
            return false;
        }
    }

    async fillCheckboxQuestion(question) {
        const checkboxInputs = question.element.querySelectorAll('input[type="checkbox"]');
        
        if (checkboxInputs.length === 0) {
            this.log('‚ö†Ô∏è No checkbox inputs found', 'warning');
            return;
        }
        
        this.log(`‚òëÔ∏è Found ${checkboxInputs.length} checkbox options`);
        
        // For checkboxes, we can select multiple options
        const maxSelections = Math.min(
            checkboxInputs.length,
            this.currentFormData.maxCheckboxSelections || Math.ceil(checkboxInputs.length / 2)
        );
        
        const numToSelect = Math.floor(Math.random() * maxSelections) + 1;
        const shuffled = Array.from(checkboxInputs).sort(() => 0.5 - Math.random());
        
        for (let i = 0; i < numToSelect; i++) {
            await this.selectCheckboxChoice(shuffled[i]);
            await this.delay(200, 400);
        }
    }

    async selectCheckboxChoice(input) {
        try {
            this.log(`‚òëÔ∏è Selecting checkbox: "${this.getInputLabel(input)}"`);
            
            input.scrollIntoView({ behavior: 'smooth', block: 'center' });
            await this.sleep(200);
            
            input.click();
            await this.sleep(100);
            
            if (input.checked) {
                this.log('‚úÖ Checkbox selected successfully');
            } else {
                this.log('‚ö†Ô∏è Checkbox selection may have failed');
            }
            
        } catch (error) {
            this.log(`‚ùå Error selecting checkbox: ${error.message}`, 'error');
        }
    }

    async fillTextQuestion(question) {
        const textInputs = question.element.querySelectorAll('input[type="text"], textarea');
        
        if (textInputs.length === 0) {
            this.log('‚ö†Ô∏è No text inputs found', 'warning');
            return;
        }
        
        for (const input of textInputs) {
            const customText = this.getCustomTextForQuestion(question) || 
                             this.generateRandomText(input);
            
            await this.fillTextInput(input, customText);
            await this.delay(200, 400);
        }
    }

    getCustomTextForQuestion(question) {
        const questionText = this.getQuestionText(question.element);
        
        if (!questionText || !this.currentFormData.customFields) {
            return null;
        }
        
        for (const field of this.currentFormData.customFields) {
            if (field.question && questionText.toLowerCase().includes(field.question.toLowerCase())) {
                return field.value;
            }
        }
        
        return null;
    }

    generateRandomText(input) {
        const placeholder = input.placeholder || input.getAttribute('aria-label') || '';
        
        // Generate appropriate text based on input type or placeholder
        if (placeholder.toLowerCase().includes('email') || placeholder.toLowerCase().includes('e-mail')) {
            return `user${Math.floor(Math.random() * 1000)}@example.com`;
        } else if (placeholder.toLowerCase().includes('phone')) {
            return `09${Math.floor(Math.random() * 100000000).toString().padStart(8, '0')}`;
        } else if (placeholder.toLowerCase().includes('name')) {
            const names = ['Nguyen Van A', 'Tran Thi B', 'Le Van C', 'Pham Thi D'];
            return names[Math.floor(Math.random() * names.length)];
        } else {
            return `Sample text ${Math.floor(Math.random() * 1000)}`;
        }
    }

    async fillTextInput(input, text) {
        try {
            if (!input) {
                this.log('‚ùå Input element is null/undefined', 'error');
                return false;
            }

            this.log(`üìù Filling text input with: "${text}"`);
            
            // Check if input is disabled or readonly
            if (input.disabled || input.readOnly) {
                this.log('‚ö†Ô∏è Input is disabled or readonly, skipping', 'warning');
                return false;
            }

            if (input.scrollIntoView) {
                input.scrollIntoView({ behavior: 'smooth', block: 'center' });
                await this.sleep(200);
            }
            
            if (input.focus) {
                input.focus();
            }
            input.value = '';
            await this.sleep(100);
            
            // Type character by character for more natural behavior
            for (const char of text) {
                input.value += char;
                if (input.dispatchEvent) {
                    input.dispatchEvent(new Event('input', { bubbles: true }));
                }
                await this.sleep(50);
            }
            
            if (input.dispatchEvent) {
                input.dispatchEvent(new Event('change', { bubbles: true }));
            }
            if (input.blur) {
                input.blur();
            }
            
            this.log('‚úÖ Text input filled successfully');
            return true;
            
        } catch (error) {
            this.log(`‚ùå Error filling text input: ${error.message}`, 'error');
            return false;
        }
    }

    async fillRatingQuestion(question) {
        const ratingElements = question.element.querySelectorAll('[role="slider"], .rating-component input, .rating-scale input');
        
        if (ratingElements.length === 0) {
            this.log('‚ö†Ô∏è No rating elements found', 'warning');
            return;
        }
        
        for (const ratingElement of ratingElements) {
            await this.setRatingValue(ratingElement);
            await this.delay(200, 400);
        }
    }

    async setRatingValue(element) {
        try {
            const elementMin = parseInt(element.getAttribute('aria-valuemin') || '1');
            const elementMax = parseInt(element.getAttribute('aria-valuemax') || '5');
            
            // Use settings from popup for rating range
            const settingsMin = this.currentFormData.ratingMin || 4;
            const settingsMax = this.currentFormData.ratingMax || 5;
            
            this.log(`üéØ Rating settings loaded - Min: ${settingsMin}, Max: ${settingsMax}`);
            this.log(`üìä Element bounds - Min: ${elementMin}, Max: ${elementMax}`);
            
            // Make sure the settings range is within element bounds
            const actualMin = Math.max(elementMin, settingsMin);
            const actualMax = Math.min(elementMax, settingsMax);
            
            // If settings range is invalid, use element range
            const finalMin = actualMin <= actualMax ? actualMin : elementMin;
            const finalMax = actualMin <= actualMax ? actualMax : elementMax;
            
            // Generate weighted random value favoring higher ratings
            let selectedValue;
            if (finalMin === finalMax) {
                selectedValue = finalMin;
            } else {
                // Weighted selection favoring higher values
                const range = finalMax - finalMin + 1;
                const weights = [];
                for (let i = 0; i < range; i++) {
                    weights.push(Math.pow(2, i + 1)); // Exponential weight favoring higher values
                }
                const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
                let random = Math.random() * totalWeight;
                
                for (let i = weights.length - 1; i >= 0; i--) {
                    random -= weights[i];
                    if (random <= 0) {
                        selectedValue = finalMax - i;
                        break;
                    }
                }
                
                if (!selectedValue) {
                    selectedValue = finalMax; // fallback to highest
                }
            }
            
            this.log(`‚≠ê Setting rating to: ${selectedValue}/${elementMax} (range: ${finalMin}-${finalMax}, settings: ${settingsMin}-${settingsMax})`);
            
            element.scrollIntoView({ behavior: 'smooth', block: 'center' });
            await this.sleep(200);
            
            if (element.tagName === 'INPUT') {
                element.value = selectedValue;
                element.dispatchEvent(new Event('change', { bubbles: true }));
            } else {
                element.setAttribute('aria-valuenow', selectedValue);
                element.click();
            }
            
            this.log('‚úÖ Rating set successfully');
            
        } catch (error) {
            this.log(`‚ùå Error setting rating: ${error.message}`, 'error');
        }
    }

    async fillSelectQuestion(question) {
        const selectElements = question.element.querySelectorAll('select');
        
        if (selectElements.length === 0) {
            this.log('‚ö†Ô∏è No select elements found', 'warning');
            return;
        }
        
        for (const select of selectElements) {
            await this.selectRandomOption(select);
            await this.delay(200, 400);
        }
    }

    async selectRandomOption(select) {
        try {
            const options = Array.from(select.options).filter(option => option.value && option.value !== '');
            
            if (options.length === 0) {
                this.log('‚ö†Ô∏è No valid options found in select', 'warning');
                return;
            }
            
            const randomOption = options[Math.floor(Math.random() * options.length)];
            
            this.log(`üîΩ Selecting option: "${randomOption.text}"`);
            
            select.scrollIntoView({ behavior: 'smooth', block: 'center' });
            await this.sleep(200);
            
            select.value = randomOption.value;
            select.dispatchEvent(new Event('change', { bubbles: true }));
            
            this.log('‚úÖ Select option chosen successfully');
            
        } catch (error) {
            this.log(`‚ùå Error selecting option: ${error.message}`, 'error');
        }
    }

    async fillMatrixQuestion(question) {
        this.log(`üìä Processing Matrix/Likert question...`);
        
        // Method 1: Check for new Microsoft Forms Likert structure with likerSubQuestion
        let likertSubQuestions = question.element.querySelectorAll('[data-automation-id="likerSubQuestion"]');
        
        if (likertSubQuestions.length > 0) {
            this.log(`üìã Found ${likertSubQuestions.length} Likert sub-questions using new structure`);
            return await this.fillLikertSubQuestions(likertSubQuestions);
        }
        
        // Method 2: Legacy - Find Likert table rows using multiple selectors like console script
        let matrixRows = question.element.querySelectorAll('tr[role="radiogroup"]');
        
        if (matrixRows.length === 0) {
            // Try alternative row selectors like console script
            matrixRows = question.element.querySelectorAll('tr');
            this.log(`üîç No radiogroup rows found, trying all tr elements: ${matrixRows.length}`);
            
            // Filter for rows that have radio inputs
            matrixRows = Array.from(matrixRows).filter(row => {
                const radios = row.querySelectorAll('input[type="radio"]');
                return radios.length > 0;
            });
        }
        
        if (matrixRows.length === 0) {
            this.log('‚ö†Ô∏è No matrix rows found - this might be a misidentified question type', 'warning');
            
            // Fallback: try to handle as regular radio question if it has radio inputs
            const radioInputs = question.element.querySelectorAll('input[type="radio"]');
            if (radioInputs.length > 0) {
                this.log(`üîÑ Fallback: treating as radio question with ${radioInputs.length} options`);
                // Convert to radio question format and process
                const radioQuestion = {
                    ...question,
                    type: 'radio'
                };
                await this.fillRadioQuestion(radioQuestion);
                return;
            }
            
            this.log('‚ö†Ô∏è No fallback possible - skipping question');
            return;
        }
        
        this.log(`üìä Found ${matrixRows.length} Likert scale rows to fill (legacy structure)`);
        return await this.fillLikertTableRows(matrixRows);
    }
    
    async fillLikertSubQuestions(likertSubQuestions) {
        const settingsMin = this.currentFormData.ratingMin || 4;
        const settingsMax = this.currentFormData.ratingMax || 5;
        
        this.log(`üìä Likert sub-questions settings - Min: ${settingsMin}, Max: ${settingsMax}`);
        
        for (const subQuestion of likertSubQuestions) {
            try {
                // Get the question text from the sub-question
                const questionTextElement = subQuestion.querySelector('.text-format-content, [class*="-qh-"]');
                const questionText = questionTextElement ? questionTextElement.textContent.trim() : 'Unknown question';
                
                this.log(`üìã Processing Likert sub-question: ${questionText.substring(0, 80)}...`);
                
                // Find all radio inputs in this sub-question
                let radioInputs = subQuestion.querySelectorAll('input[type="radio"]');
                
                if (radioInputs.length === 0) {
                    this.log(`‚ö†Ô∏è No radio inputs found in sub-question`, 'warning');
                    continue;
                }
                
                this.log(`Found ${radioInputs.length} rating options (1-${radioInputs.length})`);
                
                // Debug: Log all radio inputs found
                Array.from(radioInputs).forEach((radio, index) => {
                    const value = radio.value;
                    const automationValue = radio.getAttribute('data-automation-value');
                    const ariaLabel = radio.getAttribute('aria-label');
                    const name = radio.name;
                    this.log(`   Radio ${index + 1}: value="${value}", automation-value="${automationValue}", aria-label="${ariaLabel}", name="${name}"`);
                });
                
                // Use position-based selection
                const selectedInput = this.selectRatingFromInputsPositional(this.ensureArray(radioInputs), settingsMin, settingsMax);
                
                if (selectedInput) {
                    // Get display information
                    const ariaLabel = selectedInput.getAttribute('aria-label');
                    const value = selectedInput.value;
                    const automationValue = selectedInput.getAttribute('data-automation-value');
                    const displayValue = ariaLabel || value || automationValue || 'unknown';
                    const actualPosition = ariaLabel ? `position ${ariaLabel}` : `value ${value}`;
                    
                    this.log(`üéØ Selecting rating: ${displayValue} (${actualPosition}) for "${questionText.substring(0, 40)}..."`);
                    
                    // Use comprehensive click method
                    const success = await this.selectRadioInputComprehensive(selectedInput);
                    
                    if (success) {
                        this.log(`‚úÖ Successfully selected: ${displayValue}`);
                    } else {
                        this.log(`‚ùå Failed to select: ${displayValue}`, 'error');
                    }
                } else {
                    this.log(`‚ùå No suitable rating found for sub-question`, 'error');
                }
                
                await this.delay(200, 400);
                
            } catch (error) {
                this.log(`‚ùå Error processing Likert sub-question: ${error.message}`, 'error');
            }
        }
    }
    
    async fillLikertTableRows(matrixRows) {
        // Get rating settings from popup
        const settingsMin = this.currentFormData.ratingMin || 4;
        const settingsMax = this.currentFormData.ratingMax || 5;
        
        this.log(`üìä Matrix question rating settings - Min: ${settingsMin}, Max: ${settingsMax}`);
        
        for (const row of matrixRows) {
            try {
                // Get the statement text for this row
                const statementElement = row.querySelector('[data-automation-id="likerStatementTd"]');
                const statementText = statementElement ? statementElement.textContent.trim() : 'Unknown statement';
                
                this.log(`üìã Processing Likert row: ${statementText.substring(0, 60)}...`);
                
                // Find all radio inputs in this row - try multiple selectors like console script
                let radioInputs = row.querySelectorAll('input[type="radio"][data-automation-id="radio"]');
                
                if (radioInputs.length === 0) {
                    // Try alternative selectors
                    radioInputs = row.querySelectorAll('input[type="radio"]');
                    this.log(`üîç Using fallback selector, found ${radioInputs.length} radio inputs`);
                }
                
                if (radioInputs.length === 0) {
                    this.log(`‚ö†Ô∏è No radio inputs found in row`, 'warning');
                    continue;
                }
                
                this.log(`Found ${radioInputs.length} rating options (1-${radioInputs.length})`);
                
                // Debug: Log all radio inputs found (like console script)
                Array.from(radioInputs).forEach((radio, index) => {
                    const value = radio.value;
                    const automationValue = radio.getAttribute('data-automation-value');
                    const ariaLabel = radio.getAttribute('aria-label');
                    this.log(`   Radio ${index + 1}: value="${value}", automation-value="${automationValue}", aria-label="${ariaLabel}"`);
                });
                
                // Use position-based selection like console script
                const selectedInput = this.selectRatingFromInputsPositional(this.ensureArray(radioInputs), settingsMin, settingsMax);
                
                if (selectedInput) {
                    // Get display information
                    const ariaLabel = selectedInput.getAttribute('aria-label');
                    const value = selectedInput.value;
                    const automationValue = selectedInput.getAttribute('data-automation-value');
                    const displayValue = ariaLabel || value || automationValue || 'unknown';
                    const actualPosition = ariaLabel ? `position ${ariaLabel}` : `value ${value}`;
                    
                    this.log(`üéØ Selecting rating: ${displayValue} (${actualPosition}) for "${statementText.substring(0, 40)}..."`);
                    
                    // Use comprehensive click method like console script
                    const success = await this.selectRadioInputComprehensive(selectedInput);
                    
                    if (success) {
                        this.log(`‚úÖ Successfully selected: ${displayValue}`);
                    } else {
                        this.log(`‚ùå Failed to select: ${displayValue}`, 'error');
                    }
                } else {
                    this.log(`‚ùå No suitable rating found for row`, 'error');
                }
                
                await this.delay(200, 400);
                
            } catch (error) {
                this.log(`‚ùå Error processing Likert row: ${error.message}`, 'error');
            }
        }
    }

    selectRatingFromInputsPositional(inputs, settingsMin, settingsMax) {
        if (!inputs || inputs.length === 0) return null;
        
        // Convert NodeList to Array if needed - safe conversion
        const inputsArray = this.ensureArray(inputs);
        
        this.log(`üîç ENHANCED rating analysis for user range ${settingsMin}-${settingsMax} from ${inputsArray.length} inputs:`);
        
        // Enhanced input analysis with multiple detection strategies
        const inputAnalysis = inputsArray.map((input, index) => {
            const analysis = {
                input,
                index,
                ariaLabel: input.getAttribute('aria-label') || '',
                value: input.value || '',
                id: input.id || '',
                name: input.name || '',
                automationValue: input.getAttribute('data-automation-value') || '',
                detectedValues: []
            };
            
            // Strategy 1: Extract from aria-label
            const ariaMatch = analysis.ariaLabel.match(/(\d+)/);
            if (ariaMatch) {
                analysis.detectedValues.push({ 
                    value: parseInt(ariaMatch[1]), 
                    source: 'aria-label',
                    confidence: 0.9 
                });
            }
            
            // Strategy 2: Extract from value attribute
            if (analysis.value && /^\d+$/.test(analysis.value)) {
                analysis.detectedValues.push({ 
                    value: parseInt(analysis.value), 
                    source: 'value',
                    confidence: 0.8 
                });
            }
            
            // Strategy 3: Extract from automation value
            if (analysis.automationValue && /^\d+$/.test(analysis.automationValue)) {
                analysis.detectedValues.push({ 
                    value: parseInt(analysis.automationValue), 
                    source: 'automation-value',
                    confidence: 0.7 
                });
            }
            
            // Strategy 4: Extract from ID
            if (analysis.id) {
                const idMatch = analysis.id.match(/(\d+)/);
                if (idMatch) {
                    analysis.detectedValues.push({ 
                        value: parseInt(idMatch[1]), 
                        source: 'id',
                        confidence: 0.6 
                    });
                }
            }
            
            // Strategy 5: Position-based (1-indexed)
            analysis.detectedValues.push({ 
                value: index + 1, 
                source: 'position',
                confidence: 0.5 
            });
            
            // Select best detected value (highest confidence)
            analysis.bestValue = analysis.detectedValues.length > 0 ? 
                analysis.detectedValues.reduce((best, current) => 
                    current.confidence > best.confidence ? current : best
                ) : null;
            
            return analysis;
        });
        
        // Log detailed analysis
        this.log(`üìä Enhanced input analysis:`);
        inputAnalysis.forEach(analysis => {
            const best = analysis.bestValue;
            this.log(`   [${analysis.index}] best: ${best.value} (${best.source}, conf: ${best.confidence}) | aria: "${analysis.ariaLabel}" | value: "${analysis.value}"`);
        });
        
        // Apply strict user preference filtering
        const validCandidates = inputAnalysis.filter(analysis => {
            if (!analysis.bestValue) return false;
            
            const value = analysis.bestValue.value;
            const isInRange = value >= settingsMin && value <= settingsMax;
            
            if (isInRange) {
                this.log(`‚úÖ VALID: input[${analysis.index}] value=${value} is in user range ${settingsMin}-${settingsMax}`);
            } else {
                this.log(`‚ùå EXCLUDED: input[${analysis.index}] value=${value} outside user range ${settingsMin}-${settingsMax}`);
            }
            
            return isInRange;
        });
        
        if (validCandidates.length === 0) {
            this.log(`‚ö†Ô∏è STRICT COMPLIANCE: No options in user range ${settingsMin}-${settingsMax}`, 'warning');
            this.log(`üìã Available values: [${inputAnalysis.map(a => a.bestValue?.value).join(', ')}]`);
            
            // Check if we should suggest scale adjustment
            const allValues = inputAnalysis.map(a => a.bestValue?.value).filter(v => v);
            const minAvailable = Math.min(...allValues);
            const maxAvailable = Math.max(...allValues);
            
            this.log(`üí° SUGGESTION: Form scale is ${minAvailable}-${maxAvailable}, user preferences are ${settingsMin}-${settingsMax}`);
            
            // Return null to maintain strict compliance
            return null;
        }
        
        // Sort candidates by detected value for proper weighting
        validCandidates.sort((a, b) => a.bestValue.value - b.bestValue.value);
        
        this.log(`üéØ Valid candidates (${validCandidates.length}):`);
        validCandidates.forEach(candidate => {
            this.log(`   Index ${candidate.index}: value ${candidate.bestValue.value} (${candidate.bestValue.source})`);
        });
        
        // Enhanced weighted selection with user bias
        const selectedCandidate = this.performEnhancedWeightedSelection(validCandidates, settingsMin, settingsMax);
        
        if (selectedCandidate) {
            this.log(`‚úÖ FINAL SELECTION: index ${selectedCandidate.index}, value ${selectedCandidate.bestValue.value} (${selectedCandidate.bestValue.source})`);
            return selectedCandidate.input;
        }
        
        this.log('‚ùå Selection failed despite valid candidates', 'error');
        return null;
    }

    performEnhancedWeightedSelection(validCandidates, settingsMin, settingsMax) {
        if (validCandidates.length === 1) {
            this.log(`üéØ Single candidate selection`);
            return validCandidates[0];
        }
        
        // Parse user-defined weights from config (JSON format for dynamic ranges)
        let userWeights = {};
        try {
            const userWeightsStr = this.currentFormData.likertWeights || '{"5":50,"4":40,"3":7,"2":2,"1":1}';
            
            // Handle both old format (CSV) and new format (JSON)
            if (userWeightsStr.includes(',')) {
                // Legacy CSV format "50,40,7,2,1" - assume 5,4,3,2,1 order
                const weights = userWeightsStr.split(',').map(w => parseFloat(w.trim()) || 1);
                weights.forEach((weight, index) => {
                    userWeights[5 - index] = weight; // Map to 5,4,3,2,1
                });
            } else {
                // New JSON format {"5":50, "4":40, "3":7, ...}
                userWeights = JSON.parse(userWeightsStr);
            }
        } catch (e) {
            this.log(`‚ö†Ô∏è Error parsing weights, using defaults: ${e.message}`);
            userWeights = {5: 50, 4: 40, 3: 7, 2: 2, 1: 1};
        }
        
        this.log(`üìä User-defined Likert weights: ${JSON.stringify(userWeights)}`);
        
        const weights = validCandidates.map((candidate, index) => {
            const value = candidate.bestValue.value;
            const confidence = candidate.bestValue.confidence;
            
            // Get user-defined weight for this exact rating value
            const userWeight = userWeights[value] || userWeights[value.toString()] || 1;
            
            // Base weight from user configuration
            let weight = userWeight;
            
            // Confidence bonus (small modifier to maintain user's preference)
            weight *= (0.8 + confidence * 0.2);
            
            // Small bonus for values in user's preferred range
            if (value >= settingsMin && value <= settingsMax) {
                weight *= 1.1; // 10% bonus for being in range
            }
            
            this.log(`üìä Weight calculation for value ${value}:`);
            this.log(`   - User weight for rating ${value}: ${userWeight}`);
            this.log(`   - Confidence modifier: ${confidence}`);
            this.log(`   - Range bonus: ${value >= settingsMin && value <= settingsMax ? '1.1x' : '1.0x'}`);
            this.log(`   - Final weight: ${weight.toFixed(3)}`);
            
            return weight;
        });
        
        // Weighted random selection
        const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
        let random = Math.random() * totalWeight;
        
        this.log(`üé≤ Weighted selection: total=${totalWeight.toFixed(3)}, random=${random.toFixed(3)}`);
        
        for (let i = weights.length - 1; i >= 0; i--) {
            random -= weights[i];
            if (random <= 0) {
                const selected = validCandidates[i];
                this.log(`üéØ Selected candidate ${i}: value ${selected.bestValue.value} (weight: ${weights[i].toFixed(3)}/${totalWeight.toFixed(3)})`);
                return selected;
            }
        }
        
        // Fallback to highest value
        const fallback = validCandidates[validCandidates.length - 1];
        this.log(`üéØ Fallback to highest: value ${fallback.bestValue.value}`);
        return fallback;
    }

    async selectRadioInputComprehensive(selectedInput) {
        // Comprehensive radio input selection like console script
        let attempts = 0;
        let success = false;
        const maxAttempts = 3;
        
        while (!success && attempts < maxAttempts) {
            attempts++;
            this.log(`üîÑ Attempt ${attempts}/${maxAttempts} for radio input`);
            
            try {
                // Scroll into view
                selectedInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
                await this.sleep(200);
                
                // Method 1: Direct radio input manipulation
                this.log(`   Method 1: Direct radio input`);
                selectedInput.checked = true;
                selectedInput.dispatchEvent(new Event('change', { bubbles: true }));
                selectedInput.dispatchEvent(new Event('click', { bubbles: true }));
                
                await this.sleep(200);
                
                // Verify selection
                if (selectedInput.checked) {
                    this.log(`‚úÖ Method 1 successful: direct input manipulation`);
                    success = true;
                } else {
                    this.log(`   Method 1 failed, trying alternatives...`);
                    
                    // Method 2: Click the label wrapper
                    const label = selectedInput.closest('label');
                    if (label) {
                        this.log(`   Method 2: Label click`);
                        label.click();
                        await this.sleep(200);
                        if (selectedInput.checked) {
                            this.log(`‚úÖ Method 2 successful: label click`);
                            success = true;
                        }
                    }
                    
                    // Method 3: Click the span wrapper
                    if (!success) {
                        const span = selectedInput.closest('[data-automation-id="radio"]');
                        if (span) {
                            this.log(`   Method 3: Span wrapper click`);
                            span.click();
                            await this.sleep(200);
                            if (selectedInput.checked) {
                                this.log(`‚úÖ Method 3 successful: span click`);
                                success = true;
                            }
                        }
                    }
                    
                    // Method 4: Click the table cell
                    if (!success) {
                        const td = selectedInput.closest('td');
                        if (td) {
                            this.log(`   Method 4: Table cell click`);
                            td.click();
                            await this.sleep(200);
                            if (selectedInput.checked) {
                                this.log(`‚úÖ Method 4 successful: cell click`);
                                success = true;
                            }
                        }
                    }
                    
                    // Method 5: MouseEvent simulation
                    if (!success) {
                        this.log(`   Method 5: MouseEvent simulation`);
                        const rect = selectedInput.getBoundingClientRect();
                        selectedInput.dispatchEvent(new MouseEvent('mousedown', {
                            bubbles: true,
                            cancelable: true,
                            clientX: rect.left + rect.width / 2,
                            clientY: rect.top + rect.height / 2
                        }));
                        await this.sleep(20);
                        selectedInput.dispatchEvent(new MouseEvent('mouseup', {
                            bubbles: true,
                            cancelable: true,
                            clientX: rect.left + rect.width / 2,
                            clientY: rect.top + rect.height / 2
                        }));
                        selectedInput.dispatchEvent(new MouseEvent('click', {
                            bubbles: true,
                            cancelable: true,
                            clientX: rect.left + rect.width / 2,
                            clientY: rect.top + rect.height / 2
                        }));
                        await this.sleep(200);
                        if (selectedInput.checked) {
                            this.log(`‚úÖ Method 5 successful: MouseEvent`);
                            success = true;
                        }
                    }
                }
                
                if (!success && attempts < maxAttempts) {
                    this.log(`‚ö†Ô∏è All methods failed in attempt ${attempts}, retrying...`);
                    await this.sleep(500);
                }
                
            } catch (error) {
                this.log(`‚ùå Error in attempt ${attempts}: ${error.message}`, 'error');
            }
        }
        
        return success;
    }

    isElementVisible(element) {
        if (!element) return false;
        
        try {
            const rect = element.getBoundingClientRect();
            const style = window.getComputedStyle(element);
            
            // Standard visibility check
            const isStandardVisible = rect.width > 0 && 
                                    rect.height > 0 && 
                                    style.display !== 'none' && 
                                    style.visibility !== 'hidden' && 
                                    style.opacity !== '0';
            
            // For radio inputs, they might be hidden but their parent/label is visible
            if (!isStandardVisible && element.type === 'radio') {
                // Check if parent container is visible
                const parent = element.closest('label') || 
                              element.closest('[role="radio"]') || 
                              element.parentElement;
                
                if (parent) {
                    const parentRect = parent.getBoundingClientRect();
                    const parentStyle = window.getComputedStyle(parent);
                    
                    const isParentVisible = parentRect.width > 0 && 
                                          parentRect.height > 0 && 
                                          parentStyle.display !== 'none' && 
                                          parentStyle.visibility !== 'hidden' && 
                                          parentStyle.opacity !== '0';
                    
                    if (isParentVisible) {
                        this.log(`üîç Radio input hidden but parent is visible: ${this.getInputLabel(element)}`);
                        return true;
                    }
                }
            }
            
            if (!isStandardVisible && this.debug) {
                // Debug info for invisible elements
                this.log(`‚ùå Element not visible: rect=${rect.width}x${rect.height}, display=${style.display}, visibility=${style.visibility}, opacity=${style.opacity}`, 'warning');
            }
            
            return isStandardVisible;
        } catch (error) {
            this.log(`‚ùå Error checking element visibility: ${error.message}`, 'error');
            return false;
        }
    }

    performComprehensiveValidation() {
        this.log('üß™ Performing comprehensive form validation...');
        
        const validationResult = {
            isValid: true,
            errors: [],
            warnings: [],
            successMessage: '',
            details: {
                totalQuestions: 0,
                answeredQuestions: 0,
                requiredQuestions: 0,
                answeredRequiredQuestions: 0,
                validationErrors: 0,
                criticalErrors: 0
            }
        };
        
        try {
            // Step 1: Check for visible validation errors
            const validationErrors = this.checkValidationErrors();
            validationResult.details.validationErrors = validationErrors.length;
            
            if (validationErrors.length > 0) {
                validationResult.errors.push(...validationErrors);
                validationResult.isValid = false;
            }
            
            // Step 2: Check form completeness
            const completenessCheck = this.checkFormCompleteness();
            validationResult.details = { ...validationResult.details, ...completenessCheck.details };
            
            if (!completenessCheck.isComplete) {
                validationResult.errors.push(...completenessCheck.errors);
                validationResult.warnings.push(...completenessCheck.warnings);
                
                // Only mark as invalid if there are critical completion issues
                if (completenessCheck.hasCriticalIssues) {
                    validationResult.isValid = false;
                }
            }
            
            // Step 3: Check for form processing state
            const processingCheck = this.checkFormProcessingState();
            if (!processingCheck.isReady) {
                validationResult.warnings.push(processingCheck.message);
            }
            
            // Step 4: Final validation assessment
            const criticalErrors = validationResult.errors.filter(error => 
                this.isCriticalValidationError(error)
            );
            validationResult.details.criticalErrors = criticalErrors.length;
            
            if (criticalErrors.length > 0) {
                validationResult.isValid = false;
            }
            
            // Generate success message
            if (validationResult.isValid) {
                validationResult.successMessage = `Form ready for submission (${validationResult.details.answeredQuestions}/${validationResult.details.totalQuestions} questions answered, ${validationResult.details.answeredRequiredQuestions}/${validationResult.details.requiredQuestions} required answered)`;
            }
            
            this.log(`üìä Validation summary:`);
            this.log(`   - Total questions: ${validationResult.details.totalQuestions}`);
            this.log(`   - Answered: ${validationResult.details.answeredQuestions}`);
            this.log(`   - Required: ${validationResult.details.requiredQuestions}`);
            this.log(`   - Required answered: ${validationResult.details.answeredRequiredQuestions}`);
            this.log(`   - Validation errors: ${validationResult.details.validationErrors}`);
            this.log(`   - Critical errors: ${validationResult.details.criticalErrors}`);
            this.log(`   - Overall valid: ${validationResult.isValid}`);
            
            return validationResult;
            
        } catch (error) {
            this.log(`‚ùå Error during comprehensive validation: ${error.message}`, 'error');
            return {
                isValid: false,
                errors: [`Validation process failed: ${error.message}`],
                warnings: [],
                successMessage: '',
                details: validationResult.details
            };
        }
    }

    checkValidationErrors() {
        // Enhanced validation error detection
        const errorSelectors = [
            '[role="alert"]',
            '.error-message',
            '.validation-error',
            '[data-automation-id*="error"]',
            '[data-automation-id*="Error"]',
            '.field-error',
            '.form-error',
            '[aria-invalid="true"]',
            '.required-field-missing',
            '.ms-TextField-errorMessage',
            '.error-text',
            '.validation-message',
            '[data-testid*="error"]'
        ];
        
        const errors = [];
        
        errorSelectors.forEach(selector => {
            const errorElements = document.querySelectorAll(selector);
            errorElements.forEach(element => {
                if (this.isElementVisible(element) && element.textContent.trim()) {
                    const errorText = element.textContent.trim();
                    if (errorText.length > 0 && errorText.length < 500) {
                        errors.push(errorText);
                    }
                }
            });
        });
        
        // Check for red styling (common for errors)
        const redElements = document.querySelectorAll('[style*="color: red"], [style*="color:red"], .error, .invalid');
        redElements.forEach(element => {
            const style = window.getComputedStyle(element);
            const isRedText = style.color.includes('rgb(255, 0, 0)') || 
                             style.color.includes('red') ||
                             style.color.includes('rgb(220, 53, 69)'); // Bootstrap danger color
            
            if (isRedText && this.isElementVisible(element)) {
                const text = element.textContent.trim();
                if (text && text.length > 0 && text.length < 300 && !errors.includes(text)) {
                    errors.push(text);
                }
            }
        });
        
        // Remove duplicates and filter out false positives
        const uniqueErrors = [...new Set(errors)].filter(error => {
            const lowerError = error.toLowerCase();
            // Filter out common false positives
            return !lowerError.includes('optional') && 
                   !lowerError.includes('help') &&
                   !lowerError.includes('info') &&
                   lowerError.length > 3;
        });
        
        return uniqueErrors;
    }

    checkFormCompleteness() {
        const result = {
            isComplete: true,
            hasCriticalIssues: false,
            errors: [],
            warnings: [],
            details: {
                totalQuestions: 0,
                answeredQuestions: 0,
                requiredQuestions: 0,
                answeredRequiredQuestions: 0
            }
        };
        
        try {
            // Get all visible questions on the page
            const questionElements = document.querySelectorAll(`
                [data-automation-id="questionItem"],
                .office-form-question,
                [data-automation-id="question"],
                [role="radiogroup"]
            `);
            
            result.details.totalQuestions = questionElements.length;
            
            for (const questionElement of questionElements) {
                if (!this.isElementVisible(questionElement)) continue;
                
                const isRequired = this.isQuestionRequired(questionElement);
                if (isRequired) {
                    result.details.requiredQuestions++;
                }
                
                const isAnswered = this.isQuestionAnswered(questionElement);
                if (isAnswered) {
                    result.details.answeredQuestions++;
                    if (isRequired) {
                        result.details.answeredRequiredQuestions++;
                    }
                }
                
                // Check for critical issues
                if (isRequired && !isAnswered) {
                    const questionText = this.getQuestionText(questionElement);
                    const errorMsg = `Required question not answered: ${questionText?.substring(0, 50) || 'Unknown question'}`;
                    result.errors.push(errorMsg);
                    result.hasCriticalIssues = true;
                    result.isComplete = false;
                }
            }
            
            // Check overall completion rate
            const completionRate = result.details.totalQuestions > 0 ? 
                result.details.answeredQuestions / result.details.totalQuestions : 1;
            
            if (completionRate < 0.5) {
                result.warnings.push(`Low completion rate: ${Math.round(completionRate * 100)}% of questions answered`);
            }
            
        } catch (error) {
            this.log(`‚ùå Error checking form completeness: ${error.message}`, 'error');
            result.errors.push(`Completeness check failed: ${error.message}`);
            result.isComplete = false;
        }
        
        return result;
    }

    isQuestionAnswered(questionElement) {
        try {
            // Check different types of form controls
            const radioInputs = questionElement.querySelectorAll('input[type="radio"]');
            if (radioInputs.length > 0) {
                return Array.from(radioInputs).some(input => input.checked);
            }
            
            const checkboxInputs = questionElement.querySelectorAll('input[type="checkbox"]');
            if (checkboxInputs.length > 0) {
                return Array.from(checkboxInputs).some(input => input.checked);
            }
            
            const textInputs = questionElement.querySelectorAll('input[type="text"], textarea');
            if (textInputs.length > 0) {
                return Array.from(textInputs).some(input => input.value.trim().length > 0);
            }
            
            const selectInputs = questionElement.querySelectorAll('select');
            if (selectInputs.length > 0) {
                return Array.from(selectInputs).some(select => select.value && select.value !== '');
            }
            
            const sliders = questionElement.querySelectorAll('[role="slider"]');
            if (sliders.length > 0) {
                return Array.from(sliders).some(slider => 
                    slider.getAttribute('aria-valuenow') !== null
                );
            }
            
            return false;
        } catch (error) {
            this.log(`‚ùå Error checking if question is answered: ${error.message}`, 'error');
            return false; // Assume not answered if we can't determine
        }
    }

    checkFormProcessingState() {
        try {
            // Check if form is in processing state (loading, submitting, etc.)
            const processingIndicators = [
                '.loading',
                '.spinner',
                '[data-loading="true"]',
                '.submitting',
                '[disabled="true"]'
            ];
            
            for (const selector of processingIndicators) {
                const elements = document.querySelectorAll(selector);
                if (elements.length > 0 && Array.from(elements).some(el => this.isElementVisible(el))) {
                    return {
                        isReady: false,
                        message: 'Form appears to be in processing state'
                    };
                }
            }
            
            return {
                isReady: true,
                message: 'Form is ready for interaction'
            };
        } catch (error) {
            return {
                isReady: true,
                message: 'Could not determine processing state'
            };
        }
    }

    isCriticalValidationError(error) {
        const criticalKeywords = [
            'required',
            'mandatory',
            'must',
            'cannot be empty',
            'field is empty',
            'please select',
            'please enter',
            'invalid format',
            'not valid'
        ];
        
        const lowerError = error.toLowerCase();
        return criticalKeywords.some(keyword => lowerError.includes(keyword));
    }

    async submitForm() {
        this.log('üì§ Looking for submit button...');
        
        const submitSelectors = [
            'button[type="submit"]',
            'input[type="submit"]',
            'button[data-automation-id="submitButton"]',
            'button[data-automation-id="questionnaireSubmitButton"]',
            '.submit-button',
            '[role="button"][aria-label*="Submit"]',
            '[role="button"][aria-label*="G·ª≠i"]',
            '[data-automation-id*="submit"]',
            '[data-automation-id*="Submit"]'
        ];
        
        // Also search by text content
        const allButtons = document.querySelectorAll('button, input[type="submit"], [role="button"], div[role="button"]');
        
        let submitButton = null;
        
        this.log(`üîç Found ${allButtons.length} potential button elements`);
        
        // Try selectors first
        for (const selector of submitSelectors) {
            submitButton = document.querySelector(selector);
            if (submitButton && this.isElementVisible(submitButton)) {
                this.log(`üéØ Found submit button via selector: ${selector}`);
                break;
            }
        }
        
        // If no button found via selectors, search by text
        if (!submitButton) {
            const submitTexts = ['submit', 'g·ª≠i', 'send', 'continue', 'ti·∫øp t·ª•c', 'ho√†n th√†nh'];
            
            for (const button of allButtons) {
                const text = button.textContent.toLowerCase().trim();
                this.log(`üîç Checking button: "${text}"`);
                
                if (submitTexts.some(submitText => text.includes(submitText)) && 
                    this.isElementVisible(button)) {
                    submitButton = button;
                    this.log(`üéØ Found submit button via text search: "${text}"`);
                    break;
                }
            }
        }
        
        if (!submitButton) {
            throw new Error('Kh√¥ng t√¨m th·∫•y n√∫t Submit');
        }
        
        try {
            this.log('üöÄ Clicking submit button...');
            
            submitButton.scrollIntoView({ behavior: 'smooth', block: 'center' });
            await this.sleep(500);
            
            submitButton.click();
            await this.sleep(2000);
            
            this.log('‚úÖ Form submitted successfully');
            return true;
            
        } catch (error) {
            this.log(`‚ùå Error submitting form: ${error.message}`, 'error');
            throw error;
        }
    }

    async waitForSuccessPage() {
        this.log('‚è≥ Waiting for form submission success page...');
        
        const maxWait = 10000; // 10 seconds max wait
        const startTime = Date.now();
        
        while (Date.now() - startTime < maxWait) {
            // Look for success indicators
            const successIndicators = [
                'span[data-automation-id="submitAnother"]',
                '[data-automation-id*="success"]',
                '[data-automation-id*="Success"]'
            ];
            
            // Check for standard success selectors
            for (const selector of successIndicators) {
                try {
                    const element = document.querySelector(selector);
                    if (element && this.isElementVisible(element)) {
                        this.log('‚úÖ Success page loaded, submit another button available');
                        return true;
                    }
                } catch (error) {
                    this.log(`‚ö†Ô∏è Error checking selector ${selector}: ${error.message}`, 'warning');
                }
            }
            
            // Check for success text content (replacement for :contains() which is not supported)
            try {
                const successTexts = [
                    "Your response has been recorded",
                    "Your response was submitted",
                    "Ph·∫£n h·ªìi c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c ghi l·∫°i",
                    "Submit another response",
                    "G·ª≠i ph·∫£n h·ªìi kh√°c"
                ];
                
                for (const successText of successTexts) {
                    // Check if any element contains the success text
                    const allElements = document.querySelectorAll('div, span, p, h1, h2, h3');
                    for (const element of allElements) {
                        if (element.textContent && element.textContent.includes(successText) && this.isElementVisible(element)) {
                            this.log(`‚úÖ Success page detected via text: "${successText}"`);
                            return true;
                        }
                    }
                }
            } catch (error) {
                this.log(`‚ö†Ô∏è Error checking success text content: ${error.message}`, 'warning');
            }
            
            // Also check if the form questions are no longer visible (indicating success page)
            const questions = document.querySelectorAll('[data-automation-id="questionItem"]');
            if (questions.length === 0) {
                this.log('‚úÖ Form questions disappeared, likely on success page');
                await this.sleep(1000); // Extra wait for success page elements to fully load
                return true;
            }
            
            await this.sleep(500);
        }
        
        this.log('‚ö†Ô∏è Timed out waiting for success page', 'warning');
        return false;
    }

    async waitForFormToLoad() {
        this.log('‚è≥ Waiting for new form to load...');
        
        const maxWait = 10000; // 10 seconds max wait
        const startTime = Date.now();
        
        while (Date.now() - startTime < maxWait) {
            // Look for form elements that indicate a new form has loaded
            const formIndicators = [
                '[data-automation-id="questionItem"]',
                '[data-automation-id="question"]',
                'div[role="radiogroup"]',
                'input[type="radio"]',
                'div[class*="question"]'
            ];
            
            for (const selector of formIndicators) {
                const elements = document.querySelectorAll(selector);
                if (elements.length > 0) {
                    // Make sure at least one element is visible
                    const visibleElements = Array.from(elements).filter(el => this.isElementVisible(el));
                    if (visibleElements.length > 0) {
                        this.log(`‚úÖ New form loaded with ${visibleElements.length} form elements`);
                        await this.sleep(1000); // Extra time for all elements to fully load
                        return true;
                    }
                }
            }
            
            await this.sleep(500);
        }
        
        this.log('‚ö†Ô∏è Timed out waiting for new form to load', 'warning');
        return false;
    }

    async clickSubmitAnother() {
        this.log('üîç Looking for "Submit another response" button on success page...');
        
        // Update submit count when we reach the success page
        this.updateSubmitCount(true);
        
        // Wait for the success page to load after form submission
        await this.waitForSuccessPage();
        
        // Enhanced detection - check multiple approaches
        const detectionStrategies = [
            {
                name: 'Exact automation-id',
                selector: 'span[data-automation-id="submitAnother"]',
                getClickable: (element) => element.closest('div[role="link"], a, button') || element
            },
            {
                name: 'Text-based search',
                selector: null,
                getClickable: (element) => {
                    // Search for elements containing "Submit another" text
                    const candidates = document.querySelectorAll('div, span, a, button');
                    for (const candidate of candidates) {
                        const text = candidate.textContent?.trim().toLowerCase();
                        if (text && (text.includes('submit another') || text.includes('g·ª≠i ph·∫£n h·ªìi kh√°c'))) {
                            return candidate.closest('div[role="link"], a, button') || candidate;
                        }
                    }
                    return null;
                }
            },
            {
                name: 'Role-based search',
                selector: 'div[role="link"][tabindex="0"]',
                getClickable: (element) => {
                    const text = element.textContent?.trim().toLowerCase();
                    return (text && (text.includes('submit') || text.includes('another') || text.includes('g·ª≠i'))) ? element : null;
                }
            },
            {
                name: 'Class pattern search',
                selector: 'div[class*="-hw-"]',
                getClickable: (element) => {
                    const hasSubmitText = element.textContent?.toLowerCase().includes('submit');
                    const hasTabindex = element.hasAttribute('tabindex');
                    const hasRole = element.getAttribute('role') === 'link';
                    return (hasSubmitText && (hasTabindex || hasRole)) ? element : null;
                }
            }
        ];
        
        for (const strategy of detectionStrategies) {
            try {
                this.log(`üîç Trying strategy: ${strategy.name}`);
                
                let candidates = [];
                
                if (strategy.selector) {
                    candidates = Array.from(document.querySelectorAll(strategy.selector));
                    this.log(`   Found ${candidates.length} elements with selector: ${strategy.selector}`);
                } else {
                    // Special handling for text-based search
                    const element = strategy.getClickable();
                    if (element) candidates = [element];
                }
                
                for (const candidate of candidates) {
                    const clickableElement = strategy.getClickable(candidate);
                    
                    if (clickableElement && this.isElementVisible(clickableElement)) {
                        this.log(`‚úÖ Found clickable "Submit another" element via ${strategy.name}`);
                        this.log(`   Element: ${clickableElement.tagName}.${clickableElement.className}`);
                        this.log(`   Text: "${clickableElement.textContent?.trim()}"`);
                        
                        const success = await this.performSubmitAnotherClick(clickableElement);
                        if (success) return success;
                    }
                }
            } catch (error) {
                this.log(`‚ö†Ô∏è Error in strategy ${strategy.name}: ${error.message}`, 'warning');
            }
        }
        
        // If all strategies failed, provide debug information
        this.log('‚ùå Could not find "Submit another response" button using any strategy');
        this.logSubmitAnotherDebugInfo();
        
        return { success: false, message: 'Submit another response button not found' };
    }

    logSubmitAnotherDebugInfo() {
        this.log('üîç === SUBMIT ANOTHER DEBUG INFO ===');
        
        // Log all divs with role="link"
            this.log(`üîç Trying selector: ${selector}`);
            const elements = document.querySelectorAll(selector);
            this.log(`üîç Found ${elements.length} elements with selector: ${selector}`);
            
            for (const element of elements) {
                if (!this.isElementVisible(element)) {
                    this.log(`‚ö†Ô∏è Element not visible, skipping: ${element.tagName}.${element.className}`);
                    continue;
                }
                
                this.log(`üîç Found visible element: ${element.tagName}.${element.className}`);
                
                // If it's the span, get the parent div
                let clickableElement = element;
                if (element.tagName === 'SPAN' && element.getAttribute('data-automation-id') === 'submitAnother') {
                    // Get the parent div with role="link"
                    clickableElement = element.closest('div[role="link"][tabindex="0"]') || 
                                     element.closest('div[tabindex="0"][role="link"]') || 
                                     element.closest('div[class*="-hw-"]') ||
                                     element.parentElement;
                    
                    this.log(`üéØ Span found, using parent: ${clickableElement?.tagName}.${clickableElement?.className}`);
                }
                
                // Validate the clickable element
                if (clickableElement && this.isElementVisible(clickableElement)) {
                    // Additional validation for the exact structure
                    const hasCorrectStructure = 
                        clickableElement.getAttribute('role') === 'link' &&
                        clickableElement.getAttribute('tabindex') === '0' &&
                        clickableElement.querySelector('span[data-automation-id="submitAnother"]');
                    
                    if (hasCorrectStructure) {
                        this.log(`‚úÖ Found submit another button with correct structure via selector: ${selector}`);
                        this.log(`üéØ Element: ${clickableElement.tagName}, class: ${clickableElement.className}, role: ${clickableElement.getAttribute('role')}`);
                        return await this.performSubmitAnotherClick(clickableElement);
                    } else {
                        this.log(`‚ö†Ô∏è Element found but structure doesn't match expected pattern`);
                    }
                }
            }
        }
        
        // Try text-based search with enhanced detection
        this.log('üîç Trying text-based search for submit another button...');
        const allInteractiveElements = document.querySelectorAll('div, span, button, a, [role="link"], [tabindex="0"]');
        
        for (const text of textSearches) {
            this.log(`üîç Searching for text: "${text}"`);
            
            const matchingElements = Array.from(allInteractiveElements).filter(el => {
                const elementText = el.textContent?.toLowerCase().trim();
                const searchText = text.toLowerCase();
                return elementText && (
                    elementText.includes(searchText) || 
                    elementText === searchText ||
                    elementText.replace(/\s+/g, ' ') === searchText
                );
            });
            
            this.log(`üîç Found ${matchingElements.length} elements matching "${text}"`);
            
            for (const element of matchingElements) {
                if (!this.isElementVisible(element)) {
                    this.log(`‚ö†Ô∏è Element not visible: ${element.textContent?.substring(0, 30)}`);
                    continue;
                }
                
                let clickableElement = element;
                
                // Find the best clickable element
                if (!this.isElementClickable(element)) {
                    // Try to find clickable parent
                    const potentialParents = [
                        element.closest('div[role="link"]'),
                        element.closest('div[tabindex="0"]'),
                        element.closest('[role="link"]'),
                        element.closest('[tabindex="0"]'),
                        element.closest('div[class*="clickable"]'),
                        element.closest('div[class*="button"]'),
                        element.parentElement
                    ].filter(Boolean);
                    
                    clickableElement = potentialParents.find(parent => 
                        this.isElementClickable(parent) && this.isElementVisible(parent)
                    ) || element;
                }
                
                if (clickableElement && this.isElementVisible(clickableElement)) {
                    this.log(`‚úÖ Found submit another button via text: "${text}" on element: ${clickableElement.tagName}`);
                    this.log(`üéØ Element details: classes="${clickableElement.className}", role="${clickableElement.getAttribute('role')}", tabindex="${clickableElement.getAttribute('tabindex')}"`);
                    return await this.performSubmitAnotherClick(clickableElement);
                }
            }
        }
        
        // Debug: Log page structure to understand what's available
        this.log('üîç Submit another response button not found, analyzing page structure...');
        this.logSubmitAnotherDebugInfo();
        
        this.log('‚ùå Submit another response button not found', 'warning');
        return false;
    }

    logSubmitAnotherDebugInfo() {
        this.log('üîç === SUBMIT ANOTHER DEBUG INFO ===');
        
        // Log all divs with role="link"
        const linkDivs = document.querySelectorAll('div[role="link"]');
        this.log(`üìã Found ${linkDivs.length} divs with role="link"`);
        
        linkDivs.forEach((div, index) => {
            const hasTabindex = div.hasAttribute('tabindex');
            const tabindexValue = div.getAttribute('tabindex');
            const className = div.className;
            const textContent = div.textContent?.trim().substring(0, 50);
            const hasSubmitSpan = div.querySelector('span[data-automation-id="submitAnother"]');
            
            this.log(`  [${index}] Class: "${className}", tabindex: "${tabindexValue}", hasSubmitSpan: ${!!hasSubmitSpan}`);
            this.log(`       Text: "${textContent}"`);
        });
        
        // Log all spans with data-automation-id
        const automationSpans = document.querySelectorAll('span[data-automation-id]');
        this.log(`üìã Found ${automationSpans.length} spans with data-automation-id`);
        
        automationSpans.forEach((span, index) => {
            const automationId = span.getAttribute('data-automation-id');
            const textContent = span.textContent?.trim();
            const parentInfo = `${span.parentElement?.tagName}.${span.parentElement?.className}`;
            
            this.log(`  [${index}] automation-id: "${automationId}", text: "${textContent}", parent: ${parentInfo}`);
        });
        
        // Log all elements containing "submit" or "response" text
        const allElements = document.querySelectorAll('*');
        const submitElements = Array.from(allElements).filter(el => {
            const text = el.textContent?.toLowerCase() || '';
            return text.includes('submit') && text.includes('response') && text.length < 100;
        });
        
        this.log(`üìã Found ${submitElements.length} elements containing "submit" and "response"`);
        submitElements.forEach((el, index) => {
            this.log(`  [${index}] ${el.tagName}.${el.className}: "${el.textContent?.trim()}"`);
        });
        
        this.log('üîç === END DEBUG INFO ===');
    }

    // Multi-page form navigation functions
    async proceedToNext() {
        this.log('üîç Looking for navigation buttons (Next/Submit)...');
        
        // Priority order: Next button first, then Submit button
        const buttonSelectors = [
            { selector: '[data-automation-id="nextButton"]', type: 'next' },
            { selector: 'button[aria-label*="Next"]', type: 'next' },
            { selector: 'button[aria-label*="Ti·∫øp"]', type: 'next' },
            { selector: '[data-automation-id="submitButton"]', type: 'submit' },
            { selector: 'button[type="submit"]', type: 'submit' },
            { selector: 'button[aria-label*="Submit"]', type: 'submit' },
            { selector: 'button[aria-label*="G·ª≠i"]', type: 'submit' },
            { selector: 'button[data-automation-id="questionnaireSubmitButton"]', type: 'submit' }
        ];
        
        // Also search by text content
        const textSearches = [
            { text: 'Next', type: 'next' },
            { text: 'Ti·∫øp', type: 'next' },
            { text: 'Continue', type: 'next' },
            { text: 'Ti·∫øp t·ª•c', type: 'next' },
            { text: 'Submit', type: 'submit' },
            { text: 'G·ª≠i', type: 'submit' },
            { text: 'Ho√†n th√†nh', type: 'submit' },
            { text: 'Send', type: 'submit' }
        ];
        
        // First try selector-based search
        for (const { selector, type } of buttonSelectors) {
            const button = document.querySelector(selector);
            if (button && this.isElementClickable(button)) {
                this.log(`üéØ Found ${type} button via selector: "${selector}" - "${button.textContent.trim()}"`);
                return await this.clickNavigationButton(button, type);
            }
        }
        
        // Then try text-based search on all buttons
        const allButtons = document.querySelectorAll('button, input[type="submit"], [role="button"]');
        for (const { text, type } of textSearches) {
            const button = Array.from(allButtons).find(btn => 
                btn.textContent.toLowerCase().includes(text.toLowerCase()) && 
                this.isElementClickable(btn)
            );
            
            if (button) {
                this.log(`üéØ Found ${type} button via text: "${text}" - "${button.textContent.trim()}"`);
                return await this.clickNavigationButton(button, type);
            }
        }
        
        this.log('‚ùå No navigation buttons found - form may be complete or have issues', 'warning');
        return { success: false, type: 'none' };
    }

    async clickNavigationButton(button, type) {
        try {
            this.log(`üéØ Clicking ${type} button: "${button.textContent.trim()}"`);
            
            // Scroll to button and wait
            button.scrollIntoView({ behavior: 'smooth', block: 'center' });
            await this.sleep(500);
            
            // Click the button
            const clickSuccess = await this.performClick(button);
            if (!clickSuccess) {
                this.log(`‚ùå Failed to click ${type} button`, 'error');
                return { success: false, type: type };
            }
            
            if (type === 'next') {
                this.log('üìÑ Navigating to next page...');
                
                // Wait for page transition
                await this.sleep(1500);
                
                // Wait for new page to load properly
                const pageLoaded = await this.waitForFormToLoad();
                if (!pageLoaded) {
                    this.log('‚ö†Ô∏è New page may not have loaded properly', 'warning');
                }
                
                return { success: true, type: 'next' };
                
            } else if (type === 'submit') {
                this.log('üéâ Form submitted successfully!', 'success');
                
                // Wait for submission to complete
                await this.sleep(2000);
                
                return { success: true, type: 'submit' };
            }
            
        } catch (error) {
            this.log(`‚ùå Error clicking ${type} button: ${error.message}`, 'error');
            return { success: false, type: type, error: error.message };
        }
        
        return { success: false, type: type };
    }

    async resetPageState() {
        this.log('üîÑ Resetting state for new page...');
        
        // Reset processed questions tracking
        this.processedQuestions = new Set();
        
        // Reset any other page-specific state if needed
        this.log('‚úÖ Page state reset complete');
    }

    async performClick(element) {
        if (!element) return false;
        
        try {
            this.log(`üñ±Ô∏è Attempting to click element: ${element.tagName}.${element.className}`);
            
            // Multiple click methods to ensure success
            let success = false;
            
            // Method 1: Direct click
            try {
                element.click();
                await this.sleep(100);
                success = true;
                this.log('‚úÖ Direct click successful');
            } catch (e) {
                this.log(`‚ö†Ô∏è Direct click failed: ${e.message}`);
            }
            
            // Method 2: MouseEvent simulation if direct click failed
            if (!success) {
                try {
                    const rect = element.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    const mouseEvents = ['mousedown', 'mouseup', 'click'];
                    for (const eventType of mouseEvents) {
                        element.dispatchEvent(new MouseEvent(eventType, {
                            bubbles: true,
                            cancelable: true,
                            clientX: centerX,
                            clientY: centerY
                        }));
                        await this.sleep(20);
                    }
                    
                    success = true;
                    this.log('‚úÖ MouseEvent simulation successful');
                } catch (e) {
                    this.log(`‚ö†Ô∏è MouseEvent simulation failed: ${e.message}`);
                }
            }
            
            // Method 3: Focus and keyboard if mouse events failed
            if (!success) {
                try {
                    element.focus();
                    await this.sleep(50);
                    
                    const keyEvents = ['keydown', 'keypress', 'keyup'];
                    for (const eventType of keyEvents) {
                        element.dispatchEvent(new KeyboardEvent(eventType, {
                            key: 'Enter',
                            bubbles: true,
                            cancelable: true
                        }));
                        await this.sleep(20);
                    }
                    
                    success = true;
                    this.log('‚úÖ Keyboard interaction successful');
                } catch (e) {
                    this.log(`‚ö†Ô∏è Keyboard interaction failed: ${e.message}`);
                }
            }
            
            return success;
            
        } catch (error) {
            this.log(`‚ùå Error performing click: ${error.message}`, 'error');
            return false;
        }
    }

    isElementClickable(element) {
        if (!element) return false;
        
        const style = window.getComputedStyle(element);
        return style.pointerEvents !== 'none' && 
               !element.disabled && 
               this.isElementVisible(element);
    }

    async performSubmitAnotherClick(element) {
        this.log(`üîÑ Attempting to click submit another button: ${element.tagName}.${element.className}`);
        
        // Store the element info for debugging
        const elementInfo = {
            tagName: element.tagName,
            className: element.className,
            id: element.id,
            role: element.getAttribute('role'),
            tabindex: element.getAttribute('tabindex'),
            text: element.textContent?.trim(),
            href: element.getAttribute('href'),
            onClick: element.getAttribute('onclick')
        };
        
        this.log(`üìã Element info: ${JSON.stringify(elementInfo)}`);
        
        // Ensure element is ready for interaction
        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
        await this.sleep(800);
        
        // Check if element is still visible and clickable
        if (!this.isElementVisible(element)) {
            this.log('‚ùå Element became invisible after scroll');
            return false;
        }
        
        // Method 1: Focus and click
        try {
            this.log('üîÑ Method 1: Focus and click');
            
            // Focus the element first
            if (element.focus) {
                element.focus();
                await this.sleep(200);
            }
            
            element.click();
            await this.sleep(2000); // Longer wait for navigation
            
            // Check if we're back to the form (indicating success)
            if (this.isBackToForm()) {
                this.log('‚úÖ Submit another successful - back to form (Method 1)');
                return true;
            }
        } catch (error) {
            this.log(`‚ö†Ô∏è Method 1 failed: ${error.message}`);
        }
        
        // Method 2: Comprehensive click simulation
        try {
            this.log('üîÑ Method 2: Comprehensive click simulation');
            const rect = element.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // Simulate full click sequence
            const mouseDownEvent = new MouseEvent('mousedown', {
                view: window, bubbles: true, cancelable: true,
                clientX: centerX, clientY: centerY
            });
            const mouseUpEvent = new MouseEvent('mouseup', {
                view: window, bubbles: true, cancelable: true,
                clientX: centerX, clientY: centerY
            });
            const clickEvent = new MouseEvent('click', {
                view: window, bubbles: true, cancelable: true,
                clientX: centerX, clientY: centerY
            });
            
            element.dispatchEvent(mouseDownEvent);
            await this.sleep(50);
            element.dispatchEvent(mouseUpEvent);
            await this.sleep(50);
            element.dispatchEvent(clickEvent);
            await this.sleep(2000);
            
            if (this.isBackToForm()) {
                this.log('‚úÖ Submit another successful via comprehensive click (Method 2)');
                return true;
            }
        } catch (error) {
            this.log(`‚ö†Ô∏è Method 2 failed: ${error.message}`);
        }
        
        // Method 3: Enhanced keyboard activation
        try {
            this.log('üîÑ Method 3: Enhanced keyboard activation');
            element.focus();
            await this.sleep(300);
            
            // Try Enter key
            const enterEvent = new KeyboardEvent('keydown', {
                key: 'Enter', code: 'Enter', keyCode: 13,
                bubbles: true, cancelable: true
            });
            element.dispatchEvent(enterEvent);
            await this.sleep(500);
            
            // Also try Space key (for some elements)
            const spaceEvent = new KeyboardEvent('keydown', {
                key: ' ', code: 'Space', keyCode: 32,
                bubbles: true, cancelable: true
            });
            element.dispatchEvent(spaceEvent);
            await this.sleep(2000);
            
            if (this.isBackToForm()) {
                this.log('‚úÖ Submit another successful via enhanced keyboard (Method 3)');
                return true;
            }
        } catch (error) {
            this.log(`‚ö†Ô∏è Method 3 failed: ${error.message}`);
        }
        
        // Method 4: Try clicking child elements
        try {
            this.log('üîÑ Method 4: Looking for clickable child elements');
            
            // Try child span with data-automation-id
            const childSpan = element.querySelector('span[data-automation-id="submitAnother"]');
            if (childSpan) {
                this.log('üéØ Found child span element, clicking it');
                childSpan.click();
                await this.sleep(2000);
                
                if (this.isBackToForm()) {
                    this.log('‚úÖ Submit another successful via child span (Method 4)');
                    return true;
                }
            }
            
            // Try any clickable child element
            const clickableChildren = element.querySelectorAll('span, div, a');
            for (const child of clickableChildren) {
                if (child.textContent?.toLowerCase().includes('submit') || 
                    child.textContent?.toLowerCase().includes('g·ª≠i')) {
                    this.log(`üéØ Trying clickable child: ${child.tagName}`);
                    child.click();
                    await this.sleep(2000);
                    
                    if (this.isBackToForm()) {
                        this.log('‚úÖ Submit another successful via clickable child (Method 4)');
                        return true;
                    }
                }
            }
        } catch (error) {
            this.log(`‚ö†Ô∏è Method 4 failed: ${error.message}`);
        }
        
        // Method 5: Try URL navigation if href exists
        try {
            this.log('üîÑ Method 5: URL navigation');
            const href = element.getAttribute('href');
            if (href && href !== '#') {
                this.log(`üéØ Found href: ${href}, navigating...`);
                window.location.href = href;
                await this.sleep(3000);
                
                if (this.isBackToForm()) {
                    this.log('‚úÖ Submit another successful via URL navigation (Method 5)');
                    return true;
                }
            }
        } catch (error) {
            this.log(`‚ö†Ô∏è Method 5 failed: ${error.message}`);
        }
        
        this.log('‚ùå All submit another click methods failed');
        return false;
    }
    
    isBackToForm() {
        this.log('üîç Checking if back to form...');
        
        // Check if we're back to the form by looking for form elements
        const formIndicators = [
            '[data-automation-id="questionItem"]',
            '[data-automation-id="questionContainer"]',
            'input[type="radio"]',
            'input[type="checkbox"]',
            'input[type="text"]',
            'textarea',
            'select',
            '.office-form-question',
            '[role="radiogroup"]',
            '[data-automation-id="nextButton"]',
            '[data-automation-id="submitButton"]'
        ];
        
        let foundIndicators = 0;
        for (const selector of formIndicators) {
            const elements = document.querySelectorAll(selector);
            if (elements.length > 0) {
                foundIndicators++;
                this.log(`‚úÖ Found form indicator: ${selector} (${elements.length} elements)`);
            }
        }
        
        this.log(`üìä Found ${foundIndicators} form indicators out of ${formIndicators.length}`);
        
        // Need at least 2 indicators to be confident we're back to form
        if (foundIndicators >= 2) {
            this.log('‚úÖ Confirmed: Back to form page');
            return true;
        }
        
        // Also check if we're no longer on a "thank you" or completion page
        const completionIndicators = [
            'Your response has been recorded',
            'Thank you',
            'C·∫£m ∆°n b·∫°n',
            'ƒê√£ ghi l·∫°i ph·∫£n h·ªìi',
            'response has been submitted',
            'submitAnother' // If we still see submit another, we're not back to form yet
        ];
        
        const pageText = document.body.textContent?.toLowerCase() || '';
        const hasCompletionText = completionIndicators.some(text => {
            const found = pageText.includes(text.toLowerCase());
            if (found) {
                this.log(`‚ö†Ô∏è Still on completion page - found text: "${text}"`);
            }
            return found;
        });
        
        const isBackToForm = !hasCompletionText && foundIndicators >= 2;
        this.log(`üìã Final determination: ${isBackToForm ? 'Back to form' : 'Still on completion page'}`);
        
        return isBackToForm;
    }

    logPageStructure() {
        this.log('üîç Analyzing page structure for debugging...');
        
        // Check for common form elements
        const elements = [
            { selector: '[data-automation-id="questionItem"]', name: 'Question Items' },
            { selector: '[role="radiogroup"]', name: 'Radio Groups' },
            { selector: 'input[type="radio"]', name: 'Radio Inputs' },
            { selector: 'input[type="checkbox"]', name: 'Checkboxes' },
            { selector: 'input[type="text"]', name: 'Text Inputs' },
            { selector: 'textarea', name: 'Text Areas' },
            { selector: 'select', name: 'Select Dropdowns' },
            { selector: '.office-form-question', name: 'Office Form Questions' },
            { selector: '.question-title-container', name: 'Question Titles' },
            { selector: '[data-automation-id="choiceGroupView"]', name: 'Choice Groups' }
        ];
        
        elements.forEach(({ selector, name }) => {
            const found = document.querySelectorAll(selector);
            this.log(`üìä ${name}: ${found.length} found`);
        });
        
        // Log page content hints
        const bodyText = document.body.textContent.substring(0, 500);
        this.log(`üìÑ Page content preview: ${bodyText}...`);
    }

    // System integration test method
    async performSystemIntegrationTest() {
        this.log('üß™ SYSTEM INTEGRATION TEST - Starting comprehensive validation...');
        
        const testResults = {
            timestamp: new Date().toISOString(),
            overallStatus: 'PASS',
            tests: [],
            summary: {
                passed: 0,
                failed: 0,
                warnings: 0
            }
        };
        
        try {
            // Test 1: Page Detection
            const pageTest = this.testPageDetection();
            testResults.tests.push(pageTest);
            
            // Test 2: Question Detection
            const questionTest = await this.testQuestionDetection();
            testResults.tests.push(questionTest);
            
            // Test 3: Settings Validation
            const settingsTest = this.testSettingsValidation();
            testResults.tests.push(settingsTest);
            
            // Test 4: Fixed Answers Logic
            const fixedAnswersTest = this.testFixedAnswersLogic();
            testResults.tests.push(fixedAnswersTest);
            
            // Test 5: Rating Selection Logic
            const ratingTest = this.testRatingSelectionLogic();
            testResults.tests.push(ratingTest);
            
            // Test 6: Form Validation
            const validationTest = this.testFormValidation();
            testResults.tests.push(validationTest);
            
            // Calculate summary
            testResults.tests.forEach(test => {
                if (test.status === 'PASS') {
                    testResults.summary.passed++;
                } else if (test.status === 'FAIL') {
                    testResults.summary.failed++;
                    testResults.overallStatus = 'FAIL';
                } else if (test.status === 'WARNING') {
                    testResults.summary.warnings++;
                }
            });
            
            // Log results
            this.log(`üß™ SYSTEM TEST RESULTS:`);
            this.log(`   Overall Status: ${testResults.overallStatus}`);
            this.log(`   Passed: ${testResults.summary.passed}`);
            this.log(`   Failed: ${testResults.summary.failed}`);
            this.log(`   Warnings: ${testResults.summary.warnings}`);
            
            testResults.tests.forEach(test => {
                const icon = test.status === 'PASS' ? '‚úÖ' : test.status === 'FAIL' ? '‚ùå' : '‚ö†Ô∏è';
                this.log(`   ${icon} ${test.name}: ${test.message}`);
                
                if (test.details && test.details.length > 0) {
                    test.details.forEach(detail => {
                        this.log(`      - ${detail}`);
                    });
                }
            });
            
            return testResults;
            
        } catch (error) {
            this.log(`‚ùå System integration test failed: ${error.message}`, 'error');
            testResults.overallStatus = 'FAIL';
            testResults.tests.push({
                name: 'System Test Execution',
                status: 'FAIL',
                message: `Test execution failed: ${error.message}`,
                details: []
            });
            
            return testResults;
        }
    }

    testPageDetection() {
        const test = {
            name: 'Page Detection',
            status: 'PASS',
            message: '',
            details: []
        };
        
        try {
            const isValid = this.isValidFormsPage();
            const currentUrl = window.location.href;
            
            if (isValid) {
                test.message = 'Valid Microsoft Forms page detected';
                test.details.push(`URL: ${currentUrl}`);
            } else {
                test.status = 'FAIL';
                test.message = 'Invalid or unsupported page';
                test.details.push(`URL: ${currentUrl}`);
                test.details.push('Page does not appear to be a Microsoft Forms page');
            }
            
        } catch (error) {
            test.status = 'FAIL';
            test.message = `Page detection failed: ${error.message}`;
        }
        
        return test;
    }

    async testQuestionDetection() {
        const test = {
            name: 'Question Detection',
            status: 'PASS',
            message: '',
            details: []
        };
        
        try {
            const questions = await this.getAllQuestions();
            
            if (questions.length > 0) {
                test.message = `Successfully detected ${questions.length} questions`;
                test.details.push(`Question types: ${[...new Set(questions.map(q => q.type))].join(', ')}`);
                test.details.push(`Required questions: ${questions.filter(q => q.isRequired).length}`);
            } else {
                test.status = 'WARNING';
                test.message = 'No questions detected on current page';
                test.details.push('Page may not be fully loaded or may not contain form questions');
            }
            
        } catch (error) {
            test.status = 'FAIL';
            test.message = `Question detection failed: ${error.message}`;
        }
        
        return test;
    }

    testSettingsValidation() {
        const test = {
            name: 'Settings Validation',
            status: 'PASS',
            message: '',
            details: []
        };
        
        try {
            if (!this.currentFormData) {
                test.status = 'FAIL';
                test.message = 'No form data/settings available';
                return test;
            }
            
            // Check rating settings
            const ratingMin = parseInt(this.currentFormData.ratingMin);
            const ratingMax = parseInt(this.currentFormData.ratingMax);
            
            if (isNaN(ratingMin) || isNaN(ratingMax) || ratingMin > ratingMax) {
                test.status = 'WARNING';
                test.message = 'Invalid rating range settings';
                test.details.push(`Rating range: ${this.currentFormData.ratingMin}-${this.currentFormData.ratingMax}`);
            } else {
                test.message = 'Settings validation passed';
                test.details.push(`Rating range: ${ratingMin}-${ratingMax}`);
            }
            
            // Check special questions
            if (this.currentFormData.specialQuestions && this.currentFormData.specialQuestions.length > 0) {
                test.details.push(`Fixed answers configured: ${this.currentFormData.specialQuestions.length}`);
            }
            
            // Check auto-submit setting
            test.details.push(`Auto-submit: ${this.currentFormData.autoSubmit ? 'enabled' : 'disabled'}`);
            
        } catch (error) {
            test.status = 'FAIL';
            test.message = `Settings validation failed: ${error.message}`;
        }
        
        return test;
    }

    testFixedAnswersLogic() {
        const test = {
            name: 'Fixed Answers Logic',
            status: 'PASS',
            message: '',
            details: []
        };
        
        try {
            if (!this.currentFormData.specialQuestions || this.currentFormData.specialQuestions.length === 0) {
                test.status = 'WARNING';
                test.message = 'No fixed answers configured';
                return test;
            }
            
            // Test matching logic with sample data
            const sampleQuestions = [
                'What is your favorite color?',
                'Rate your experience',
                'How satisfied are you?'
            ];
            
            let matchesFound = 0;
            
            sampleQuestions.forEach(questionText => {
                const match = this.findBestSpecialQuestionMatch(questionText, this.currentFormData.specialQuestions);
                if (match) {
                    matchesFound++;
                    test.details.push(`Sample match: "${questionText}" ‚Üí "${match.specialQuestion.answer}"`);
                }
            });
            
            test.message = `Fixed answers logic functional (${matchesFound}/${sampleQuestions.length} sample matches)`;
            
        } catch (error) {
            test.status = 'FAIL';
            test.message = `Fixed answers test failed: ${error.message}`;
        }
        
        return test;
    }

    testRatingSelectionLogic() {
        const test = {
            name: 'Rating Selection Logic',
            status: 'PASS',
            message: '',
            details: []
        };
        
        try {
            // Create mock rating inputs to test selection logic
            const mockInputs = [];
            for (let i = 1; i <= 5; i++) {
                const mockInput = {
                    getAttribute: (attr) => attr === 'aria-label' ? i.toString() : null,
                    value: i.toString(),
                    id: `rating_${i}`,
                    name: 'rating'
                };
                mockInputs.push(mockInput);
            }
            
            const settingsMin = parseInt(this.currentFormData.ratingMin) || 4;
            const settingsMax = parseInt(this.currentFormData.ratingMax) || 5;
            
            const selectedInput = this.selectRatingFromInputsPositional(mockInputs, settingsMin, settingsMax);
            
            if (selectedInput) {
                const selectedValue = parseInt(selectedInput.getAttribute('aria-label'));
                const isInRange = selectedValue >= settingsMin && selectedValue <= settingsMax;
                
                if (isInRange) {
                    test.message = `Rating selection working correctly (selected: ${selectedValue})`;
                    test.details.push(`User range: ${settingsMin}-${settingsMax}`);
                    test.details.push(`Selected value: ${selectedValue}`);
                } else {
                    test.status = 'WARNING';
                    test.message = `Rating selection outside user range (selected: ${selectedValue})`;
                }
            } else {
                test.status = 'WARNING';
                test.message = 'No rating option selected (may be intentional for strict compliance)';
            }
            
        } catch (error) {
            test.status = 'FAIL';
            test.message = `Rating selection test failed: ${error.message}`;
        }
        
        return test;
    }

    testFormValidation() {
        const test = {
            name: 'Form Validation',
            status: 'PASS',
            message: '',
            details: []
        };
        
        try {
            const validationResult = this.performComprehensiveValidation();
            
            if (validationResult.isValid) {
                test.message = 'Form validation system working correctly';
                test.details.push(validationResult.successMessage);
            } else {
                test.status = 'WARNING';
                test.message = `Form validation detected issues (${validationResult.errors.length} errors)`;
                test.details.push(...validationResult.errors.slice(0, 3)); // Show first 3 errors
            }
            
            test.details.push(`Validation errors detected: ${validationResult.details.validationErrors}`);
            test.details.push(`Critical errors: ${validationResult.details.criticalErrors}`);
            
        } catch (error) {
            test.status = 'FAIL';
            test.message = `Form validation test failed: ${error.message}`;
        }
        
        return test;
    }

    // Performance optimization: Cache frequently used DOM queries
    getCachedQuestionElements() {
        if (!this.elementCache) {
            this.elementCache = new Map();
        }
        
        // Clear old cache entries (older than 5 seconds)
        const now = Date.now();
        for (const [key, data] of this.elementCache.entries()) {
            if (now - data.timestamp > 5000) {
                this.elementCache.delete(key);
            }
        }
        
        return {
            questionItems: document.querySelectorAll('[data-automation-id="questionItem"]'),
            questionContainers: document.querySelectorAll('[data-automation-id="questionContainer"]'),
            likertContainers: document.querySelectorAll('[data-automation-id*="likert"], [data-automation-id*="matrix"]'),
            radioGroups: document.querySelectorAll('[role="radiogroup"]'),
            textInputs: document.querySelectorAll('input[type="text"], textarea'),
            checkboxes: document.querySelectorAll('input[type="checkbox"]'),
            selectElements: document.querySelectorAll('select')
        };
    }

    // Smart wait for dynamic content
    async waitForQuestionsToLoad(timeout = 3000) {
        const startTime = Date.now();
        let lastCount = 0;
        let stableCount = 0;
        
        while (Date.now() - startTime < timeout) {
            const elements = this.getCachedQuestionElements();
            const currentCount = elements.questionItems.length + elements.questionContainers.length;
            
            if (currentCount === lastCount) {
                stableCount++;
                if (stableCount >= 3) { // Stable for 3 checks
                    this.log(`‚úÖ Questions loaded and stable: ${currentCount} elements`);
                    return true;
                }
            } else {
                stableCount = 0;
                lastCount = currentCount;
            }
            
            await this.sleep(100);
        }
        
        this.log(`‚ö†Ô∏è Questions may still be loading after ${timeout}ms`);
        return false;
    }

    // Helper method to ensure input is an Array
    ensureArray(input) {
        if (!input) return [];
        if (Array.isArray(input)) return input;
        if (input.length !== undefined) return Array.from(input); // NodeList, HTMLCollection, etc.
        return [input]; // Single element
    }

    // Advanced element comparison to avoid duplicates
    areElementsSimilar(element1, element2, threshold = 0.8) {
        if (element1 === element2) return true;
        
        const getElementFingerprint = (el) => {
            const rect = el.getBoundingClientRect();
            const attrs = Array.from(el.attributes).map(attr => `${attr.name}:${attr.value}`).join('|');
            const children = Array.from(el.children).map(child => child.tagName).join(',');
            
            return {
                tagName: el.tagName,
                rect: { top: Math.round(rect.top), left: Math.round(rect.left), width: Math.round(rect.width), height: Math.round(rect.height) },
                attributes: attrs,
                children: children,
                textContent: el.textContent?.trim().substring(0, 50) || ''
            };
        };
        
        const fp1 = getElementFingerprint(element1);
        const fp2 = getElementFingerprint(element2);
        
        let similarity = 0;
        let checks = 0;
        
        // Tag name check
        if (fp1.tagName === fp2.tagName) similarity += 0.2;
        checks++;
        
        // Position similarity
        const rectDiff = Math.abs(fp1.rect.top - fp2.rect.top) + Math.abs(fp1.rect.left - fp2.rect.left);
        if (rectDiff < 10) similarity += 0.3;
        checks++;
        
        // Size similarity
        const sizeDiff = Math.abs(fp1.rect.width - fp2.rect.width) + Math.abs(fp1.rect.height - fp2.rect.height);
        if (sizeDiff < 20) similarity += 0.2;
        checks++;
        
        // Content similarity
        if (fp1.textContent && fp2.textContent) {
            const textSimilarity = this.calculateTextSimilarity(fp1.textContent, fp2.textContent);
            similarity += textSimilarity * 0.3;
            checks++;
        }
        
        return (similarity / checks) >= threshold;
    }
}

// Initialize the content script
console.log('üîç QuickFill: Initializing on URL:', window.location.href);
window.quickFillFormsV2Instance = new QuickFillFormsV2();
console.log('üöÄ QuickFill: Instance created and stored');

}